C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE BRO20W_RFCONTROL
OBJECT MODULE PLACED IN .\OUTPUT\bro20W_RFcontrol.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE APP\bro20W_RFcontrol.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\my_p
                    -roject.ORC) BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\bro20W_RFcontrol.lst) TABS(2) OBJECT(.
                    -\OUTPUT\bro20W_RFcontrol.obj)

line level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          ****文   件   名: packet.c
   3          ** 创建人: 程莺红 
   4          ** 版  本: V1.2
   5          ** 日　期: 2006年3月31日
   6          ** 描　述: 原始版本
   7          ************************************************************************************/
   8          
   9          #include <reg936.h>
  10          #include <string.h>
  11          #include <intrins.h>
  12          #include <i2c.h>
  13          #include <math.h>
  14          #include <bro20W_RFcontrol.h>
  15          #include <bro20W_RFparam.h>
  16          #include <SPI.h>
  17          #include <packet.h>
  18          #include <task.h>
  19          #include <serial.h>
  20          #include <timer.h>
  21          #include <e2prom.h>
  22          #include <readad.h>
  23          
  24          /*
  25          *********************************************************************************************************
  26          *                         射频参数初始化
  27          *
  28          * Description: 初始化RF模块的各类射频参数以及与系统相关的其余参数变量
  29          *
  30          * Arguments  : 无
  31          *
  32          * Returns    : 无
  33          *********************************************************************************************************
  34          */
  35          void InitRF()
  36          {
  37   1        unsigned char temp[10];
  38   1      
  39   1        rfPramModified = FALSE;             //射频参数修改标志  
  40   1        Task5S_time = getTime() + DELAY5S;        //初始化例行任务初始时间
  41   1        Task30S_time= getTime() + 100;          //第一次写温度补偿在启动后1S后
  42   1        Task100MS_time = getTime();
  43   1      
  44   1        SrcSwitch = 1;
  45   1        LD = 1;
  46   1        LD2 = 0;
  47   1        SM2 = 0;                                        //
  48   1        softDownLoad = UNDO;              //初始化为非下载状态
  49   1        ack_flag = NO_ERR;                //初始化应答标志
  50   1        gtestflag = 0;                  //初始化测试状态
  51   1        gtestRfTemp = 50;               //初始化测试温度值
  52   1        gpreRfTemp = 50;                  //初始化温度状态
  53   1        gcurRfTemp = 50;
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 2   

  54   1        gAtttempval = 0;
  55   1      
  56   1        __PlusSwitchState = CLOSE;
  57   1        
  58   1        re_Pwr = 0;
  59   1        PA_current = 0;
  60   1        OutputPwr = 0;
  61   1      //  rfmute = 1;                      //    使能ADF4350,高电平有效
  62   1      //  readE2promStr(1,EE_RFSW,&AutoSwitch);       //射频开关
  63   1        AutoSwitch = CLOSE;                     //上位机开关
  64   1        gRFSW = CLOSE;
  65   1        
  66   1        switchRF(gRFSW);
  67   1        
  68   1        delay(1);
  69   1        watchdog();
  70   1        
  71   1        //读取温度补偿值
  72   1        readE2promStr(sizeof(__temp_que),EE_TEMPER_BUCHANG,__temp_que);
  73   1        
  74   1        //Source select
  75   1        readE2promStr(1,EE_SOURCE_SELECT,temp);
  76   1        RFSrcSelect = (temp[0] == 0xFF)? SRC_INTERNAL:temp[0];
  77   1        
  78   1        readE2promStr(4,EE_CenFreq,temp);       //读取中心频率
  79   1        swapBytes(temp,(unsigned char *)&gCenFreq,4);
  80   1      
  81   1        readE2promStr(1,EE_RF_No,&gRF_No);        //读取射频模块地址
  82   1      
  83   1        gPALimCompensate();
  84   1        writeAD5314(gPALim,DAPOWER_LIM_CHAN);
  85   1      
  86   1        watchdog();       
  87   1        writeLM75(0x90,0x00,2);              //选择指针为配置寄存器
  88   1      
  89   1        readE2promStr(1,EE_PAProtectLim,&gPAProtecttLim);//写功放保护温度门限
  90   1        writeLM75(0x03,gPAProtecttLim,3); 
  91   1        
  92   1        readE2promStr(1,EE_PAResetLim,&gPAResetLim);   //写功放重启温度门限
  93   1        writeLM75(0x02,gPAResetLim,3);
  94   1      
  95   1        readE2promStr(1,EE_BaseTemp_VALUE,&gBaseTemp);      //读取温度补偿温度基准值
  96   1        watchdog();  
  97   1        readE2promStr(1,EE_Att1,&gGain);
  98   1        writeAtt1(gGain);
  99   1        writePLL();                     
 100   1        delay(1);                 
 101   1        readTemperatur();
 102   1        execCheckSumQ();                   //初始化计算校验和   
 103   1      }
 104          
 105          
 106          /*写LM75中的功放保护和恢复门限*/
 107          void writeLM75(char point,char value,unsigned char num)
 108          {
 109   1        char temp[5];
 110   1        if(num==2)
 111   1        {
 112   2          temp[0] = 0x01;
 113   2          temp[1] = 0x18;                //高字节在前
 114   2        }
 115   1        else if(num==3)
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 3   

 116   1        {
 117   2          temp[0] = point;
 118   2          temp[1] = value;                //高字节在前
 119   2          temp[2] = 0x00;                 //低字节在后
 120   2        }
 121   1        watchdog();                  //这里似乎没必要喂狗
 122   1        ISendStrExt(0x90,temp,num);
 123   1      }
 124          
 125          
 126          /*开关射频*/
 127          void switchRF(unsigned char value)
 128          {
 129   1        unsigned char temp[4];
 130   1        
 131   1        readE2promStr(2,EE_DA_CHANNEL_B,temp);
 132   1        swapBytes(temp,(unsigned char *)&gDAoutB,2);
 133   1        if ( gDAoutB > 1023 )gDAoutB = 0;
 134   1        
 135   1        readE2promStr(2,EE_DA_CHANNEL_C,temp);
 136   1        swapBytes(temp,(unsigned char *)&gDAoutC,2);
 137   1        if ( gDAoutC > 1023 )gDAoutC = 0;
 138   1        
 139   1        if(value == CLOSE)
 140   1        {
 141   2      #ifdef NEW_PLAD
 142   2          writeAD5314(0,'B');
 143   2          writeAD5314(0,'C'); 
 144   2      #endif
 145   2          RFswitch = 1;
 146   2        }
 147   1        else
 148   1        {
 149   2      #ifdef NEW_PLAD   
 150   2          writeAD5314(gDAoutB,'B');
 151   2          writeAD5314(gDAoutC,'C');     
 152   2      #endif    
 153   2          RFswitch = 0;
 154   2        }
 155   1      }
 156          /***********************************************************************************************
 157          函数名:   writeDA5741
 158          功能:   唤醒DA及A\B\C\D通道的DA输出
 159          参数说明: 
 160                value:送入5741的数据  
 161                function:功能选择 W:为唤醒DA    A/B/C/D:对A/B/C/D通道操作
 162          操作说明: Immediately following CS high-to-low transition, the data is shifted synchronously 
 163                and latched into the input register on the falling edge of the serial clock input(SCLK)
 164          ************************************************************************************************/
 165          /*
 166          void writeDA5741(unsigned int value,unsigned char function)
 167          {
 168            value <<=2;
 169            value &=0xFFFC;       //取DA数据(bit2~bit11)
 170          
 171            switch(function)
 172            {
 173              case  'W':      //wake up A、B、C、D通道
 174                value |= 0x0000;  
 175                break;
 176          
 177              case  'A':
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 4   

 178                value |= 0x0000;
 179                break;
 180              
 181              case  'B':
 182                value |= 0x1000;
 183                break;
 184          
 185              case  'C':
 186                value |= 0x2000;  //高4位为模式控制位Shift data from input register to DAC register, OUTC updated
 187                break;
 188          
 189              case  'D':
 190                value |= 0x3000;
 191                break;
 192          
 193              default:
 194                break;  
 195            }
 196            LD = 1;
 197            LD = 0;
 198            MSend_bit(value,16);
 199            LD = 1; 
 200          } */
 201          
 202          
 203          void writeAD5314(unsigned short value,unsigned char channel)            //DA转换器
 204          {
 205   1        //温度补偿
 206   1        signed char xdata curTemp = gcurRfTemp/2;
 207   1        
 208   1        if( curTemp < TEMP_NORMAL && TEMP_NORMAL != TEMP_LOW )
 209   1        {
 210   2          value -= (TEMP_NORMAL_VALUE - TEMP_LOW_VALUE)*(TEMP_NORMAL - curTemp)*1.0/(TEMP_NORMAL - TEMP_LOW);
 211   2        } 
 212   1        else 
 213   1        if( curTemp >= TEMP_NORMAL && TEMP_NORMAL != TEMP_HIGH )
 214   1        {
 215   2          value += (TEMP_NORMAL_VALUE - TEMP_HIGH_VALUE)*(curTemp - TEMP_NORMAL)*1.0/(TEMP_NORMAL - TEMP_HIGH);   
 216   2        }
 217   1        
 218   1        value <<=2;
 219   1        value &=0xFFFC; 
 220   1        if(channel=='A')
 221   1        {
 222   2          value |= 0x2000;        //高4位为模式控制位
 223   2        }
 224   1        else if(channel=='B') 
 225   1        {
 226   2          value |= 0x6000;
 227   2        }
 228   1        else if(channel=='C') 
 229   1        {
 230   2          value |= 0xA000;
 231   2        }
 232   1        else  
 233   1        {
 234   2          value |= 0xE000;
 235   2        }
 236   1        LD = 1;
 237   1        LD = 0;
 238   1        MSend_bit(value,16);
 239   1        LD = 1;
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 5   

 240   1      }
 241          //减器Att1--1U5(前部衰减器)
 242          /**********对衰减值的做了相应的处理 2--10,    4-20       6-30*/
 243          void writeAtt1(unsigned char att1)
 244          {
 245   1        unsigned short value  ;
 246   1        LE1 = 0;
 247   1        value =(unsigned int)att1/2;
 248   1        /*  switch(value)
 249   1        {
 250   1        case 2: value=20;break;
 251   1        case 4 : value=40;break;
 252   1        case 6:value=60;break;
 253   1      
 254   1        default: break;
 255   1        }
 256   1      */
 257   1        value<<=10;
 258   1        MSend_bit(value,6); 
 259   1        LE1 = 1;
 260   1        LE1 = 0;
 261   1      }
 262            /*
 263          //设置总的衰减值
 264          unsigned char writeAttenuator(unsigned char attVal)
 265          {
 266            gAtt1 = attVal <<= 1;
 267            gAtt1 += gAtttempval;
 268            gAtt1 += gGainOffset;
 269          
 270            if(gAtt1 > 0x3F)
 271            {
 272              gAtt1 = 0x3F;
 273            }
 274          
 275            writeAtt1(gAtt1); 
 276            return TRUE;    
 277          }  */
 278          /*
 279          **********************************************************************************************************
             -*****
 280          *                         输出功率限幅值补偿
 281          *
 282          * Description: 补偿限幅值 
 283          *
 284          * Arguments  : 无
 285          *
 286          * Returns    : 无
 287          **********************************************************************************************************
             -*****
 288          */
 289          void gPALimCompensate()
 290          {   
 291   1          unsigned char temp[4];
 292   1          unsigned char gPALimNumerN;
 293   1        signed short calVal;
 294   1      
 295   1          readE2promStr(2, EE_gPALim, temp);                      
 296   1        swapBytes(temp, (unsigned char *)&gPALim, 2);
 297   1      
 298   1      #if debug == 1
                gPALim = 600;
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 6   

              #endif
 301   1      
 302   1        readE2promStr(1,EE_gPALimNumer,temp);     //读取 功率限幅补偿分子         
 303   1        swapBytes(temp,(unsigned char *)&gPALimNumer,1);
 304   1      
 305   1        readE2promStr(1,EE_gPequDenomi,temp);     //读取 功率补偿分母         
 306   1        swapBytes(temp,(unsigned char *)&gPequDenomi,1);
 307   1      
 308   1        readE2promStr(4,EE_gPBmFreq,temp);        //读取 基准频率
 309   1        swapBytes(temp,(unsigned char *)&gPBmFreq,4);
 310   1      
 311   1        gPALimNumerN = ~gPALimNumer + 1;
 312   1      
 313   1        calVal = gPALim;
 314   1        
 315   1        if(gCenFreq < gPBmFreq)
 316   1          {
 317   2          if(gPALimNumer < 0)
 318   2          {
 319   3            calVal += (gPBmFreq - gCenFreq) * gPALimNumerN / (gPequDenomi * 1000);
 320   3          }
 321   2          else
 322   2          {
 323   3            calVal -= (gPBmFreq - gCenFreq) * gPALimNumer / (gPequDenomi * 1000);
 324   3          }
 325   2        }
 326   1        else if(gPBmFreq < gCenFreq)
 327   1        {
 328   2          if(gPALimNumer < 0)
 329   2          {
 330   3            calVal -= (gCenFreq - gPBmFreq) * gPALimNumerN / (gPequDenomi * 1000);
 331   3          }
 332   2          else
 333   2          {
 334   3            calVal += (gCenFreq - gPBmFreq) * gPALimNumer / (gPequDenomi * 1000);
 335   3          }
 336   2        }
 337   1      
 338   1        //检查范围，防止溢出
 339   1        if(calVal < 0)
 340   1        {
 341   2          gPALim = 0;
 342   2        }
 343   1        else if(calVal > 1023)                   //防止输出限幅值溢出，导致掉功率
 344   1        {
 345   2          gPALim = 1023;
 346   2        }
 347   1        else
 348   1        {
 349   2          gPALim = calVal;
 350   2        }
 351   1      
 352   1      
 353   1      }
 354          /*
 355          **********************************************************************************************************
             -******
 356          *                         读取温度
 357          *
 358          * Description: 读取温度，定时执行，更新温度值 
 359          *
 360          * Arguments  : 无
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 7   

 361          *
 362          * Returns    : 无
 363          **********************************************************************************************************
             -*******
 364          */
 365          void readTemperatur()
 366          {
 367   1        signed short value = 0;
 368   1      
 369   1        gpreRfTemp =  gcurRfTemp;
 370   1        
 371   1      #ifdef NEW_PLAD 
 372   1        IRcvStr(0x92,0x00,(unsigned char*)&value,2);      //读取温度，其中指针寄存器为00
 373   1      #else 
                IRcvStr(0x90,0x00,(unsigned char*)&value,2);      //读取温度，其中指针寄存器为00
              #endif
 376   1        
 377   1        value >>= 7;
 378   1        gcurRfTemp = value;
 379   1      
 380   1      /*  if(gtestflag == 0)                    //不在调试状态下，使用实际温度
 381   1        {
 382   1          gainCo = gcurRfTemp - gBaseTemp*2;               
 383   1        }
 384   1        else if(gtestflag == 2)
 385   1        {
 386   1          gainCo = gtestRfTemp - gBaseTemp*2;             
 387   1        } */
 388   1      }
 389          /*
 390          **********************************************************************************************************
             -******
 391          *                         温度补偿
 392          *
 393          * Description: 根据读取的温度值，对衰减值和锁相环分别进行温补操作 
 394          *
 395          * Arguments  : 无
 396          *
 397          * Returns    : 无
 398          **********************************************************************************************************
             -*******
 399          */
 400          /*
 401          void tempCompensate() 
 402          {
 403          //  unsigned char numerator, denominator;
 404            int gainCotemp;
 405          
 406            if( (softDownLoad == DOING)||(gtestflag==1) )
 407            {
 408              return;
 409            }
 410          
 411          //  readE2promStr(1,EE_GainNumer,&numerator);         //增益温补系数分子
 412          //  readE2promStr(1,EE_GainDenomi,&denominator);        //增益温补系数分母
 413          //  readE2promStr(1,EE_TEMP_VALUE,&gTempgain);        //读取温度基准值
 414            if( gTempgain > 16 ) 
 415            {   
 416              gTempgain = 9;
 417            } 
 418             
 419            gainCotemp = gainCo*gGainNumer; //gGainNumer
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 8   

 420            if(gGainDenomi == 0)
 421            {
 422              gGainDenomi = 100;
 423            }
 424            gainCotemp = gainCotemp/gGainDenomi;
 425              
 426            gainCotemp = gTempgain - gainCotemp;
 427            if(gainCotemp < 0)
 428            {
 429              gAtttempval = 0;
 430            }
 431            else if(gainCotemp > 0x3F)
 432            {
 433              gAtttempval = 0x3F;
 434            }
 435            else
 436            {
 437              gAtttempval = (unsigned char)gainCotemp;
 438            }
 439          
 440            writeAttenuator(gAtteVal);
 441          
 442            rfPramModified = FALSE;             //射频参数修改标志  
 443          
 444          }*/
 445          
 446          /*写锁相环4350*/
 447          void progPLL(unsigned long value)
 448          { 
 449   1        unsigned char num_bit,i;
 450   1        unsigned long masque_bit;
 451   1        unsigned char x;
 452   1      
 453   1        num_bit = 32;
 454   1        masque_bit = 0x80000000;  
 455   1        
 456   1        CLK = 0;          //初始状态
 457   1        LD2 = 1;
 458   1      
 459   1        LD2 = 0;
 460   1        for(i=0;i<num_bit;i++)
 461   1        {
 462   2          if((value & masque_bit)==0)
 463   2          {
 464   3            DATA = 0;
 465   3          }     
 466   2          else
 467   2          {
 468   3            DATA = 1; 
 469   3          }
 470   2          for(x=0;x<2;x++)
 471   2          {
 472   3          }
 473   2          CLK = 1;
 474   2          value <<= 1;
 475   2          CLK = 0;
 476   2        }
 477   1        LD2 = 1;
 478   1      }
 479          
 480          /*
 481          void writePLL()
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 9   

 482          {
 483            progPLL(0x00580005);     //5
 484            progPLL(0x0095003c);
 485            progPLL(0x000004b3);
 486            progPLL(0x60004ec2);
 487            progPLL(0x08008191);
 488            progPLL(0x00b48000);     //0
 489          }
 490          /*
 491          **********************************************************************************************************
             -******
 492          *                         写锁相环ADF4350
 493          *
 494          * Description: 根据设定的中心频率, 中频频率, 频率偏移, 频率步进, 频率温度补偿系数计算出各寄存器值, 再调用p
             -rogPLL
 495          *
 496          * Arguments  : 无
 497          *
 498          * Returns    : 无
 499          **********************************************************************************************************
             -*******
 500          */
 501          void writePLL()
 502          {
 503   1          #define R0_INIT   0x00000000
 504   1        //
 505   1        //DB31             ～                  DB4 DB3 DB2 DB1 DB0
 506   1        //0    0    0    0    0    0    0          0
 507   1        //0                ～                  0   0   0   0   0
 508   1      
 509   1        #define R1_INIT   0x08008001
 510   1        //        PRESCALER
 511   1        //DB31～DB28  DB27       DB26 DB25 DB24 DB23  ～ DB16 DB15 DB14 DB13 DB12 DB11 ～ DB4 DB3 DB2 DB1 DB0
 512   1        //0       8               0     0     8           0    0      1
 513   1        //0   ～0     1      0    0    0    0    ～   0   1    0    0    0    0    ～ 0   0   0   0   1 
 514   1      
 515   1        #define R2_INIT   0x18004EC2
 516   1        //     NOISE-MODE[1:0] MUXOUT[2:0]     REF-DOU RDIV2               DOUB-BUFF  CHARGE-PUMP[3:0]  LDF LDP PD-POLA 
             -PD  CP-THR  COUNT-RESET
 517   1        //DB31 DB30 DB29       DB28 DB27 DB26  DB25    DB24   DB23 ～ DB16 DB15 DB14 DB13       DB12 DB11 B10 DB9
             - DB8 DB7 DB6     DB5 DB4     DB3         DB2 DB1 DB0
 518   1        //1             8             0    0     4             E          C             2
 519   1        //0    0    0          1    1    0     0       0      0    ～ 0    0    1    0      0  1    1   1   0   1   1
             -        0    0      0           0   1   0
 520   1      
 521   1      
 522   1        #define R3_INIT   0x000004B3
 523   1        //          CSR     CLK-DIV[1:0]
 524   1        //DB31 ～ DB20 DB19 DB18 DB17 DB16 DB15    DB14 DB13 DB12 DB11 DB10 DB9 DB8 DB7 DB6 DB5 DB4 DB3 DB2 DB1 D
             -B0
 525   1        //0  0  0    0                   0                      4         B       3
 526   1        //0    ～ 0    0    0    0    0    0       0    0    0    0    1    0   0   1   0   1   1   0   0   1   1
             - 
 527   1        
 528   1        #define R4_INIT   0x0085041C        //0x00850414
 529   1        //         FEEDBACK DIV-SEL[2:0]       BAND-SELECT-CLOCK-DIVIDER-VALUE[7:0]        VCO-POW  MTLD AUXOUT-SEL AU
             -XOUT-EN  AUXOUT-POW[1:0]  RFOUT-EN OUTPOW[1:0]
 530   1        //DB31 ～ DB24   DB23     DB22 DB21 DB20     DB19 DB18 DB17 DB16 DB15 DB14 DB13 DB12     DB11     B10  DB
             -9        DB8       DB7 DB6         DB5      DB4 DB3     DB2 DB1 DB0
 531   1        //0    0     8               5           0             4                  1              C
 532   1        //0    ～ 0      1        0    0    0        0    1    0    1    0    0    0    0    0      1    0      0     0 
             -0      0     1   1     1   0   0
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 10  

 533   1      
 534   1        #define R5_INIT   0x00580005
 535   1        //         LD-PIN[1:0]                       
 536   1        //DB31 ～ DB24   DB23 DB22   DB21 DB20 DB19 DB18 DB17 DB16 DB15 ～ DB4 DB3 DB2 DB1 DB0
 537   1        //0    0     5             8                   0 0 0       5
 538   1        //0    ～ 0      0    1      0    1    1    0    0    0    0    ～ 0   0   1   0   1
 539   1            
 540   1            
 541   1        unsigned long counterTemp,counterN,divSel,refFreq;
 542   1        unsigned short freqStep;
 543   1        unsigned char temp[4];
 544   1       
 545   1      
 546   1        readE2promStr(4,EE_RefFreq,temp);                 //读取参考频率，4个字节
 547   1        swapBytes(temp, (unsigned char *)&refFreq,4);
 548   1      
 549   1        readE2promStr(2,EE_FreqStep,temp);                  //读取中频步进值
 550   1        swapBytes(temp, (unsigned char *)&freqStep,2);
 551   1      
 552   1      #if debug == 1
                gCenFreq = 1805000; //930000
                freqStep = 100;
                refFreq = 10000;
                gRFSW = 1;
              #endif
 558   1      
 559   1        if (freqStep == 0) 
 560   1        {
 561   2          freqStep = 25;
 562   2        }
 563   1       
 564   1      //  counterN = gCenFreq;
 565   1        counterN = RFSrcSelect?0:gCenFreq;
 566   1        //VCO只能输出2.2GHz-4.4GHz的频率，根据需要输出的频率确定VCO输出的分频值
 567   1         
 568   1        divSel = 4400000 / counterN;
 569   1        divSel = checkMBit((unsigned char)divSel);
 570   1        counterN <<= divSel;              //放大为VCO的输出频率和步进值
 571   1        freqStep <<= divSel;
 572   1        progPLL(R5_INIT);               //R5
 573   1      
 574   1        counterTemp = divSel;
 575   1        counterTemp <<= 20;
 576   1        counterTemp = counterTemp | R4_INIT | (gRFSW << 5);//射频开关关闭则不使能输出
 577   1        progPLL(counterTemp);             //R4
 578   1      
 579   1        progPLL(R3_INIT);               //R3
 580   1      
 581   1        progPLL(R2_INIT);               //R2
 582   1      
 583   1                                  //转换成对应的分频值1、2、4、8、16
 584   1        //divSel = 1 << divSel;             //计算小数分频的模
 585   1        counterTemp = refFreq;
 586   1        counterTemp /= (unsigned long)freqStep;
 587   1        counterTemp <<= 3;
 588   1        counterTemp |= R1_INIT;
 589   1        progPLL(counterTemp);             //R1
 590   1                                //计算小数分频分子
 591   1        
 592   1        counterTemp = counterN % refFreq;
 593   1        counterTemp /= (unsigned long)freqStep;
 594   1        counterTemp <<= 3;
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 11  

 595   1        counterN /= refFreq;              //计算整数分频
 596   1        counterN <<= 15;
 597   1        counterTemp |= counterN;
 598   1        progPLL(counterTemp);             //R0
 599   1        watchdog();   
 600   1      }
 601          /*
 602          *********************************************************************************************************
 603          *                         A/D转换
 604          *
 605          * Description: 根据给定的A/D转换通道，取得相应的A/D转换值
 606          *
 607          * Arguments  : channel  给定的通道号
 608          *
 609          * Returns    : value    转换结果
 610          *********************************************************************************************************
 611          */
 612          unsigned short readAD(unsigned char channel)
 613          {
 614   1        unsigned short value = 0; 
 615   1        
 616   1        ADINS  = channel;             //选择转换通道 //
 617   1        ADMODA |= 0x10;           //单次转换
 618   1        ADMODB |= 0x20;           // ADC时钟=CCLK/2,即2分频
 619   1        if(channel < CHANNEL_4)
 620   1        {
 621   2          ADCON0 = 0x05;              //立即启动
 622   2          while(!ADCON0&0x08);          //等待转换完毕
 623   2        }
 624   1        else
 625   1        {
 626   2          ADCON1 = 0x05;              //立即启动
 627   2          while(!ADCON1&0x08);          //等待转换完毕    
 628   2        }
 629   1        
 630   1        //936提供的ADC为2*4通道,是一种比较古老的ADC，与938的10位8通道ADC不兼容
 631   1        switch(channel)
 632   1        {
 633   2          case CHANNEL_0:
 634   2            value = AD0DAT0; 
 635   2          break;
 636   2          case CHANNEL_1:
 637   2            value = AD0DAT1; 
 638   2          break;
 639   2          case CHANNEL_2:
 640   2            value = AD0DAT2; 
 641   2          break;
 642   2          case CHANNEL_3:
 643   2            value = AD0DAT3; 
 644   2          break;
 645   2          case CHANNEL_4:
 646   2            value = AD1DAT0; 
 647   2          break;
 648   2          case CHANNEL_5:
 649   2            value = AD1DAT1; 
 650   2          break;
 651   2          case CHANNEL_6:
 652   2            value = AD1DAT2; 
 653   2          break;
 654   2          case CHANNEL_7:
 655   2            value = AD1DAT3; 
 656   2          break;    
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 12  

 657   2          default:break;
 658   2        }
 659   1        
 660   1        return value<<2;
 661   1      }
 662          /*
 663          *********************************************************************************************************
 664          *                         计算程序校验和
 665          *
 666          * Description: 读取flash中的代码，计算校验和
 667          *
 668          * Arguments  : 无
 669          *
 670          * Returns    : 计算结果保存在全局变量all_checksum中
 671          *********************************************************************************************************
 672          */
 673          void execCheckSumQ()
 674          {
 675   1        unsigned char code *data pt_flash;  
 676   1        all_checksum = 0;
 677   1        for (pt_flash = 0x0000; pt_flash < 0x3700; pt_flash++)
 678   1        {
 679   2          all_checksum += *pt_flash;
 680   2          watchdog();
 681   2        }
 682   1        for (pt_flash = 0x0000; pt_flash < 0x1047; pt_flash++)
 683   1        {
 684   2          all_checksum += 0xFF;
 685   2          watchdog();
 686   2        }
 687   1        
 688   1        all_checksum += 0x47;
 689   1      }
 690          //喂狗程序
 691          void watchdog(void) 
 692          {
 693   1        EA = 0;       //关闭中断 
 694   1        WFEED1 = 0xA5;    //执行清零第一部分 
 695   1        WFEED2 = 0x5A;    //执行清零第二部分 
 696   1        EA = 1;       //开中断        
 697   1      }
 698          
 699          void delay(unsigned char time)
 700          {
 701   1        unsigned char x;
 702   1        unsigned short y;
 703   1        for(x=0;x<time;x++)
 704   1        {
 705   2          watchdog();
 706   2          for(y=0;y<0x8FFF;y++);                //han
 707   2          //for(y=0;y<0x0700;y++); // 1毫秒   
 708   2        }
 709   1      }
 710          
 711          unsigned char checkMBit(unsigned char value)
 712          {
 713   1        #define MASQUE 0x80
 714   1        unsigned char i;
 715   1      
 716   1        for(i=7;i>0;i--)
 717   1        {
 718   2          if((value & MASQUE)==0x80)
C51 COMPILER V9.51   BRO20W_RFCONTROL                                                      07/11/2014 13:22:09 PAGE 13  

 719   2          {
 720   3            break;
 721   3          }
 722   2          value <<= 1;
 723   2        }
 724   1      
 725   1        return i;
 726   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2268    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      69
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
