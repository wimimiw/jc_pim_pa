C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE SERIAL
OBJECT MODULE PLACED IN .\OUTPUT\serial.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE drive\serial.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\my_project.O
                    -RC) BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\serial.lst) TABS(2) OBJECT(.\OUTPUT\serial.obj
                    -)

line level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: serial.c
   3          **创   建   人: 张小龙
   4          **修   改   人: 
   5          **最后修改日期: 2008年9月1日
   6          **最 新 版  本: V1.3
   7          **描        述: 去掉自动地址识别功能
   8          /**-------------历史版本信息------------------------------------------------------------------------------
             ---
   9          **文   件   名: serial.c
  10          **创   建   人: 程莺红
  11          **修   改   人: 
  12          **最后修改日期: 2006年5月15日
  13          **最 新 版  本: V1.3
  14          **描        述: 串口初始化、接收和发送中断处理程序
  15                  
  16          **
  17          **--------------历史版本信息----------------------------------------------------------------------------
  18          ** 创建人: 程莺红 
  19          ** 版  本: V1.2
  20          ** 日　期: 2006年3月31日
  21          ** 描　述: 原始版本
  22          **
  23          **--------------历史版本信息----------------------------------------------------------------------------
  24          ** 创建人: 程莺红 
  25          ** 版  本: V1.3
  26          ** 日　期: 2006年5月15日
  27          ** 描　述: 1、增加了串口超时操作；
  28          **
  29          ********************************************************************************************************/
  30          
  31          #include <reg938.h>
  32          #include <serial.h>
  33          #include <string.h>
  34          #include <packet.h>
  35          #include <bro20W_RFcontrol.h>
  36          #include "timer.h"
  37                              
  38          
  39          /*
  40          *********************************************************************************************************
  41          *                         串口初始化
  42          *
  43          * Description: 串口初始化以及与串口接收、发送相关参数
  44          *
  45          * Arguments  : 无
  46          *
  47          * Returns    : 无
  48          *********************************************************************************************************
  49          */
  50          void InitSerial()   
  51          {
  52   1        // 初始化串口 
C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 2   

  53   1                //485接收有效，发送禁止
  54   1        Rx_state = STA_ADDRESS1;  //初始化接收状态,第一个字节为
  55   1        pack_valid = 0;
  56   1      //    RDE = 0;            //没使用
  57   1      
  58   1        //9位数据模式
  59   1        SCON  = 0xF0;       //串口模式3，使用多机通信，接收使能
  60   1        BRGCON= 0x00;           //波特率发生器使能
  61   1      //  BRGR1 = 0x00;       //波特率115200bit/s，采用11.0592的晶振 
  62   1      //  BRGR0 = 0x50;       //在高波特率的情况下，MCU端RXD脚的电容最好别加
  63   1        BRGR1 = 0x04;       //波特率9600bit/s，采用外部11.0592的晶振 
  64   1        BRGR0 = 0x70;
  65   1      
  66   1        SSTAT = 0xE0;         //选择独立的RX/TX中断
  67   1        BRGCON= 0x03;       //启动UART的波特率发生器 
  68   1      
  69   1        //8位数据模式
  70   1      /*  SCON  = 0x50;       //串口模式3，使用多机通信，接收使能
  71   1        BRGCON= 0x00;           //波特率发生器使能
  72   1        //BRGR1 = 0x02;       //波特率9600bit/s，采用cpu内部晶振 
  73   1        //BRGR0 = 0xF0;
  74   1        
  75   1      
  76   1        BRGR1 = 0x04;       //波特率9600bit/s，采用外部11.0592的晶振 
  77   1        BRGR0 = 0x70;
  78   1      
  79   1        SSTAT = 0xA0;         //选择独立的RX/TX中断
  80   1        BRGCON= 0x03;       //启动UART的波特率发生器 
  81   1      */  
  82   1        ESR = 1;          //串口RI使能
  83   1        EST = 1;          //串口TI使能
  84   1      
  85   1      }
  86          
  87          /*
  88          *********************************************************************************************************
  89          *                         串口发送中断服务程序
  90          *
  91          * Description: 实现串口的发送，有独立的波特率发生器
  92          *
  93          * Arguments  : 无
  94          *
  95          * Returns    : 无
  96          *********************************************************************************************************
  97          */
  98          void SerialSend_ISR() small interrupt 13 
  99          {    
 100   1        if(TI)
 101   1        {
 102   2          TI = 0;
 103   2          /*commet test for uart*/
 104   2          TB8 = 0x00;         //开始发送数据字节，TB8必须为0
 105   2          Tx_ptr++;
 106   2          if(Tx_ptr<(TxBuf[4]+6))   //485通信时，最后发一个字节00，232通信时，需要去除00，防止误发
 107   2          {
 108   3            SBUF = TxBuf[Tx_ptr];
 109   3          }
 110   2          else
 111   2          {
 112   3      //      RDE =  0;    //232通信时，没使用
 113   3          } 
 114   2        }   
C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 3   

 115   1      }
 116          
 117          /*
 118          *********************************************************************************************************
 119          *                         串口接收中断服务程序
 120          *
 121          * Description: 实现串口的接收，有独立的波特率发生器
 122          *
 123          * Arguments  : 无
 124          *
 125          * Returns    : 无
 126          *********************************************************************************************************
 127          */
 128          void SerialRcv_ISR() small interrupt 4 
 129          {    
 130   1        static unsigned short recv_timer;        
 131   1        unsigned char Rx_byte;
 132   1      
 133   1        if ( getTime() - recv_timer > 10 )    //50ms
 134   1        {
 135   2          pack_valid = 0;
 136   2          Rx_state = STA_ADDRESS1;      
 137   2        }
 138   1        
 139   1        recv_timer = getTime(); 
 140   1      
 141   1        EA = 0;                       //关中断
 142   1      
 143   1        if(RI)
 144   1        {   
 145   2          RI = 0;   
 146   2            Rx_byte = SBUF;
 147   2          switch(Rx_state)
 148   2          {
 149   3            case STA_ADDRESS1:
 150   3              //if((Rx_byte==gRF_No)||(Rx_byte==0xFE))//接收到的地址为本机地址或广播地址
 151   3              //{
 152   3      //          Rx_state = STA_INIT1;       
 153   3      //          SM2 = 0;  
 154   3              //}
 155   3              //else                  //非本模块数据，则不接收
 156   3              //{
 157   3              //  Rx_state = STA_ADDRESS1;
 158   3              //}
 159   3      //        break;
 160   3            case STA_INIT1:                 //包起始第一个字节
 161   3              if(Rx_byte==SYNC1)
 162   3              {
 163   4                Rx_state = STA_INIT2; 
 164   4              }
 165   3                else                  //非本模块数据，则不接收
 166   3              {
 167   4                Rx_state = STA_ADDRESS1;
 168   4              }  
 169   3              break;
 170   3            case STA_INIT2:               //包起始第二个字节
 171   3              if(Rx_byte==SYNC2)
 172   3              {
 173   4                Rx_state = STA_ADDRESS2;  
 174   4              }
 175   3              else                  //非本模块数据，则不接收
 176   3              {
C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 4   

 177   4                Rx_state = STA_ADDRESS1;
 178   4              } 
 179   3              break; 
 180   3            case STA_ADDRESS2:                //模块地址或者广播地址
 181   3      //        if((Rx_byte==gRF_No)||(Rx_byte==0xFE))
 182   3      //        {
 183   3                Rx_state = STA_PACKSIZE;
 184   3                Rx_chksum = Rx_byte;        //校验和为异或校验
 185   3                RxBuf[0] = Rx_byte; 
 186   3      //        }
 187   3      //        else                  //非本模块数据，则不接收
 188   3      //        {
 189   3      //          Rx_state = STA_ADDRESS1;
 190   3      //        }
 191   3              break;
 192   3            case STA_PACKSIZE:                //数据单元长度
 193   3      
 194   3               Rx_chksum ^= Rx_byte;
 195   3               RxBuf[1] = Rx_byte;
 196   3               if(Rx_byte)
 197   3               {
 198   4                Rx_state = STA_CMD; 
 199   4               }  
 200   3               else                   //若数据长度为空，则回到初始化状态，不接收
 201   3               {
 202   4                 Rx_state = STA_ADDRESS1; 
 203   4               }
 204   3               break;
 205   3            case STA_CMD:                 //数据单元中的命令标识，内部命令固定为0xA0
 206   3              if(Rx_byte==FCT_CMD)
 207   3              {
 208   4                Rx_state = STA_ACK;
 209   4                RxBuf[2] = Rx_byte;
 210   4                Rx_chksum ^= Rx_byte;
 211   4              }
 212   3              else                  //若不是内部命令0xA0则不响应
 213   3              {
 214   4                Rx_state = STA_ADDRESS1;
 215   4              }
 216   3              break;
 217   3            case STA_ACK:                 //数据单元中的应答标志
 218   3              if(Rx_byte==ACK)
 219   3              {
 220   4                Rx_state = STA_OL;
 221   4                Rx_chksum ^= Rx_byte;
 222   4                RxBuf[3] = 0x00;            //回复包的校验和设置为0
 223   4                ack_flag = 0;
 224   4              }
 225   3              else
 226   3              {
 227   4                Rx_state = STA_ADDRESS1;
 228   4              }
 229   3              break;
 230   3            case   STA_OL:                //监控对象长度              
 231   3               Rx_chksum ^= Rx_byte;
 232   3               RxBuf[4] = Rx_byte;
 233   3               if(Rx_byte)
 234   3               {
 235   4                Rx_state = STA_OID1;  
 236   4               }  
 237   3               else                     
 238   3               {
C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 5   

 239   4                Rx_state = STA_ADDRESS1;    
 240   4               }
 241   3               break;
 242   3            case  STA_OID1:               //监控对象标号
 243   3               Rx_chksum ^= Rx_byte;
 244   3               RxBuf[5] = Rx_byte;
 245   3               Rx_state = STA_OID2; 
 246   3               break;
 247   3            case  STA_OID2:               //监控对象标号
 248   3               Rx_chksum ^= Rx_byte;
 249   3               RxBuf[6] = Rx_byte;
 250   3               Rx_ptr = 7;
 251   3               Rx_state = STA_OC; 
 252   3               break;
 253   3      
 254   3            case STA_OC:                //监控对象内容
 255   3               Rx_chksum ^= Rx_byte;
 256   3               RxBuf[Rx_ptr] = Rx_byte;
 257   3               Rx_ptr++;
 258   3               if((Rx_ptr-4)== RxBuf[4])        //监控对象内容接收完毕
 259   3               {
 260   4                Rx_state = STA_CHKSUM;    
 261   4               }
 262   3               if(Rx_ptr>(RxBuf[1]+2))
 263   3               {
 264   4                Rx_state = STA_ADDRESS1;
 265   4                pack_valid = 1;
 266   4                //RDE = 1;
 267   4                ack_flag = LEN_ERR;         //长度错  
 268   4                  //SM2 = 1;
 269   4                  PktHandle2S_time = 0;               //数据处理定时器清零
 270   4               }
 271   3               break;
 272   3            case STA_CHKSUM:              //接收到数据的校验和
 273   3              if(Rx_byte!=Rx_chksum)
 274   3              {
 275   4                ack_flag = DEFSUM_ERR;    
 276   4              }
 277   3              Rx_state = STA_ADDRESS1;        
 278   3              pack_valid = 1;
 279   3              PktHandle2S_time = 0;               //数据处理定时器清零
 280   3              //RDE = 1;
 281   3              //SM2 = 1;
 282   3              break;
 283   3            default:                    //重新开始接受下一个包
 284   3              Rx_state = STA_ADDRESS1;
 285   3              break;  
 286   3          } 
 287   2        } 
 288   1                                  //485发送有效，接收禁止
 289   1        EA = 1;                           //开中断
 290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    521    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.51   SERIAL                                                                07/11/2014 13:22:10 PAGE 6   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
