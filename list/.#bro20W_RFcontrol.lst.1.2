C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE BRO20W_RFCONTROL
OBJECT MODULE PLACED IN .\OUTPUT\bro20W_RFcontrol.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE APP\bro20W_RFcontrol.c BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEX
                    -TEND PRINT(.\list\bro20W_RFcontrol.lst) OBJECT(.\OUTPUT\bro20W_RFcontrol.obj)

stmt level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: RFcontrol.c
   3          **创   建   人: 程莺红
   4          **修   改   人: 
   5          **最后修改日期: 2006年4月7日
   6          **最 新 版  本: V1.3
   7          **描        述: 完成射频板的射频初始化以及操作
   8          **
   9          **--------------历史版本信息----------------------------------------------------------------------------
  10          ** 创建人: 程莺红 
  11          ** 版  本: V1.2
  12          ** 日　期: 2006年3月31日
  13          ** 描　述: 原始版本
  14          **--------------历史版本信息----------------------------------------------------------------------------
  15          ** 创建人: 程莺红 
  16          ** 版  本: V1.3
  17          ** 日　期: 2006年4月7日
  18          ** 描　述: 修改了在读取AD时，对AD采用的频率进行2分频
  19          **--------------历史版本信息----------------------------------------------------------------------------
  20          ** 创建人: 程莺红 
  21          ** 版  本: V1.4
  22          ** 日　期: 2006年4月24日
  23          ** 描　述: 修改了对EEPROM的写频率
  24          ********************************************************************************************************/
  25          
  26          #include <reg938.h>
  27          #include <string.h>
  28          #include <intrins.h>
  29          #include <i2c.h>
  30          #include <math.h>
  31          #include <bro20W_RFcontrol.h>
  32          #include <bro20W_RFparam.h>
  33          #include <SPI.h>
  34          #include <packet.h>
  35          #include <task.h>
  36          #include <serial.h>
  37          #include <timer.h>
  38          #include <e2prom.h>
  39          #include <readad.h>
  40          
  41          /*
  42          *********************************************************************************************************
  43          *                         射频参数初始化
  44          *
  45          * Description: 初始化RF模块的各类射频参数以及与系统相关的其余参数变量
  46          *
  47          * Arguments  : 无
  48          *
  49          * Returns    : 无
  50          *********************************************************************************************************
  51          */
  52          void InitRF()
  53          {
  54   1              unsigned char temp[10];
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 2   

  55   1              unsigned char bus;
  56   1              //sendInitpacket();
  57   1      
  58   1              switchRF(0);                                                                    //上电先关功放
  59   1              switchPA(0);                                                                    //上电先关射频
  60   1      
  61   1              rfPramModified = FALSE;                                                 //射频参数修改标志      
  62   1              Task5S_time = getTime() + DELAY5S;                              //初始化例行任务初始时间
  63   1              Task30S_time= getTime() + DELAY30S;
  64   1              LD = 1;
  65   1              LE1 = 0;
  66   1              LE2 =0;
  67   1              LE3 =1;
  68   1              softDownLoad = UNDO;                                                    //初始化为非下载状态
  69   1              ack_flag = NO_ERR;                                                              //初始化应答标志
  70   1              
  71   1              readE2promStr(1,EE_RF_No,&gRF_No);                              //读取射频模块地址
  72   1              readE2promStr(1,EE_RFSW,&gRFSW);                                //射频开关
  73   1              readE2promStr(1,EE_PASW,&gPASW);                                //功放开关
  74   1      
  75   1              gtestflag = 0;                                                                  //初始化测试状态
  76   1              gtestRfTemp = 50;                                                               //初始化测试温度值
  77   1              gpreRfTemp = 50;                                                                //初始化温度状态
  78   1              gcurRfTemp = 50;
  79   1              gAtttempval = 0;
  80   1              
  81   1              switchRF(gRFSW);
  82   1              switchPA(gPASW);
  83   1      
  84   1              readE2promStr(2,EE_PALim,temp);                                 //写限幅值DA,A通道                                              
  85   1              swapBytes(temp, (unsigned char *)&gPALim,2);
  86   1              writeDA1661(gPALim,'A');
  87   1              watchdog();
  88   1      
  89   1              readE2promStr(2,EE_PAIq,temp);                                  //写功放偏压DA，B通道                                                   
  90   1              swapBytes(temp, (unsigned char *)&gPAIq,2);
  91   1              if(gPAIq<0)
  92   1              {
  93   2                      gPAIq = 0;
  94   2              }
  95   1              writeDA1661(gPAIq,'B');
  96   1              watchdog();
  97   1              readE2promStr(2,EE_PAIqCo,temp);                                //读偏压温补系数                                                
  98   1              swapBytes(temp, (unsigned char *)&gPAIqCo,2);
  99   1      
 100   1              if((gRF_No&0xF0)==0)                                                    //取得通道号，上行or下行
 101   1              {
 102   2                      bus = 0;
 103   2              }
 104   1              else
 105   1              {
 106   2                      bus = 1;
 107   2              }  
 108   1              delay(3);
 109   1      
 110   1              readE2promStr(1,EE_AtteVal,&gAtteVal);                  //增益设定值
 111   1              readE2promStr(1,EE_GainOffset,&gGainOffset);    //增益调整值
 112   1              writeAttenuator(bus,gAtteVal);  
 113   1              writeLM75(0x90,0x00,2);                                                  //选择指针为配置寄存器
 114   1      
 115   1              readE2promStr(1,EE_PAProtectLim,&gPAProtecttLim);//写功放保护温度门限
 116   1              writeLM75(0x03,gPAProtecttLim,3);       
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 3   

 117   1              
 118   1              readE2promStr(1,EE_PAResetLim,&gPAResetLim);     //写功放重启温度门限
 119   1              writeLM75(0x02,gPAResetLim,3);  
 120   1      
 121   1              watchdog();
 122   1              readTemperatur();
 123   1              writePLL();                                                                             
 124   1              tempCompensate();                                                               //温度补偿
 125   1              execCheckSumQ();                                                                //初始化计算校验和              
 126   1      }
 127          /*写LM75中的功放保护和恢复门限*/
 128          void writeLM75(char point,char value,unsigned char num)
 129          {
 130   1              char temp[5];
 131   1              if(num==2)
 132   1              {
 133   2                      temp[0] = 0x01;
 134   2                      temp[1] = 0x18;                                                         //高字节在前
 135   2              }
 136   1              else if(num==3)
 137   1              {
 138   2                      temp[0] = point;
 139   2                      temp[1] = value;                                                                //高字节在前
 140   2                      temp[2] = 0x00;                                                                 //低字节在后
 141   2              }
 142   1              watchdog();
 143   1              ISendStrExt(0x90,temp,num);
 144   1      }
 145          /*开关射频*/
 146          void switchRF(unsigned char value)
 147          {
 148   1              if(value==0)
 149   1              {
 150   2                      RFswitch = 0;
 151   2              }
 152   1              else
 153   1              {
 154   2                      RFswitch = 1;
 155   2              }
 156   1      }
 157          /*开关功放*/
 158          void switchPA(unsigned char value)
 159          {
 160   1              if(value==0)
 161   1              {
 162   2                      PAswitch = 1;
 163   2              }
 164   1              else
 165   1              {
 166   2                      PAswitch = 0;
 167   2              }
 168   1      }
 169          /*写DA1661*/
 170          void writeDA1661(unsigned int value,unsigned char channel)
 171          {
 172   1              value <<=2;
 173   1              value &=0xFFFC;
 174   1              if(channel=='A')
 175   1              {
 176   2                      value |= 0x9000;                                //高4位为模式控制位
 177   2              }
 178   1              else if(channel=='B')   
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 4   

 179   1              {
 180   2                      value |= 0xA000;
 181   2              }
 182   1              LD = 1;
 183   1              LD = 0;
 184   1              CLK = 0;
 185   1              MSend_bit(value,16);
 186   1              LD = 1; 
 187   1      }
 188          /*写衰减器Att1--1U5(前部衰减器)*/
 189          void writeAtt1(unsigned char att1)
 190          {
 191   1              unsigned int value;
 192   1              LE1 = 0;
 193   1              value = (unsigned int)att1;
 194   1              value <<=10;
 195   1              MSend_bit(value,6);     
 196   1              LE1 = 1;
 197   1              LE1 = 0;
 198   1      }
 199          /*写衰减器Att2--2U6(后部衰减器)*/
 200          void writeAtt2(unsigned char att2)
 201          {
 202   1              unsigned int value;
 203   1              LE2 = 0;
 204   1              value = (unsigned int)att2;
 205   1              value <<=10;
 206   1              MSend_bit(value,6);     
 207   1              LE2 = 1;
 208   1              LE2 = 0;
 209   1      }
 210          /*设置总的衰减值*/
 211          unsigned char writeAttenuator(unsigned char bus, unsigned char attVal)
 212          {
 213   1              if(bus==0)
 214   1              {
 215   2                      if(attVal<=15)  
 216   2                      {
 217   3                              gAtt2 = gAtteVal<<1;                            //0.5dB步进需乘以2
 218   3                              gAtt2 += gGainOffset;                           //加上0.5dB步进的偏移值
 219   3                              gAtt2 += gAtttempval;                           //att2加上温度补偿值
 220   3                              writeAtt1(0);
 221   3                              gAtt1 = 0;
 222   3                      }
 223   2                      else 
 224   2                      {
 225   3                              gAtt2 = gGainOffset + 30;                       //15dB衰减值加上增益偏移
 226   3                              gAtt2 += gAtttempval;                           //att2加上温度补偿值
 227   3                              gAtt1 =gAtteVal-15;                                     //0.5dB步进需乘以2,即左移一位
 228   3                              gAtt1 <<= 1;
 229   3                              writeAtt1(gAtt1);       
 230   3                      }
 231   2              }
 232   1              else
 233   1              {
 234   2                      attVal <<= 1;
 235   2                      gAtt1 = attVal;
 236   2                      writeAtt1(gAtt1);       
 237   2                      gAtt2 = gAtttempval + gGainOffset;      
 238   2              }
 239   1              if(gAtt2 > 0x3F)
 240   1              {
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 5   

 241   2                      gAtt2 = 0x3F;
 242   2              }                               
 243   1              writeAtt2(gAtt2);                               
 244   1              return TRUE;            
 245   1      }
 246          /*写锁相环*/
 247          void progPLL(unsigned char reg,unsigned long value)
 248          {       
 249   1              unsigned char num_bit,i;
 250   1              unsigned long masque_bit;
 251   1              unsigned char x;
 252   1      
 253   1              if(reg == 'C')
 254   1              {
 255   2                      num_bit = 20;
 256   2                      masque_bit = 0x80000L;  
 257   2              }
 258   1              else
 259   1              {
 260   2                      num_bit = 21;
 261   2                      masque_bit = 0x100000L; 
 262   2              }
 263   1              
 264   1              CLK = 0;                                        //初始状态
 265   1              LE3 = 1;
 266   1      
 267   1              LE3 = 0;
 268   1              for(i=0;i<num_bit;i++)
 269   1              {
 270   2                      if((value & masque_bit)==0)
 271   2                      {
 272   3                              DATA = 0;
 273   3                      }                       
 274   2                      else
 275   2                      {
 276   3                              DATA = 1;       
 277   3                      }
 278   2                      for(x=0;x<2;x++)
 279   2                      {
 280   3                      }
 281   2                      CLK = 1;
 282   2                      value <<= 1;
 283   2                      CLK = 0;
 284   2              }
 285   1              LE3 = 1;
 286   1      }
 287          /*
 288          **********************************************************************************************************
             -******
 289          *                         写锁相环
 290          *
 291          * Description: 根据设定的中心频率, 中频频率, 频率偏移, 频率步进, 频率温度补偿系数计算出各寄存器值, 再调用p
             -rogPLL
 292          *
 293          * Arguments  : 无
 294          *
 295          * Returns    : 无
 296          **********************************************************************************************************
             -*******
 297          */
 298          void writePLL()
 299          {
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 6   

 300   1              #define F_reg       0x000092L                                                                           //功能选择寄存器值固定为0x000092L                                       
 301   1      
 302   1              unsigned int value1,value2;
 303   1              int temperature;        
 304   1              bit flag_sa;
 305   1              unsigned char temp[4];
 306   1      
 307   1              readE2promStr(2,EE_IFOffset,temp);                                                                      //读取中频调整值,2个字节（即中频偏移值）
 308   1              swapBytes(temp, (unsigned char *)&gIFOffset,2);
 309   1      
 310   1              readE2promStr(4,EE_RefFreq,temp);                                                                       //读取参考频率，4个字节
 311   1              swapBytes(temp, (unsigned char *)&gRefFreq,4);
 312   1      
 313   1              if ( ( gIFOffset < -99 ) || ( gIFOffset > 99 ) ) 
 314   1              {               
 315   2                      gIFOffset = 0;
 316   2              }
 317   1              readE2promStr(2,EE_FreqStep,temp);                                                                      //读取中频步进值
 318   1              swapBytes(temp, (unsigned char *)&gFreqStep,2);
 319   1      
 320   1      
 321   1              if (gFreqStep == 0) 
 322   1              {
 323   2                      gFreqStep = 25;
 324   2              }
 325   1              readE2promStr(4,EE_CenFreq,temp);                                                                       //读取中心频率
 326   1              swapBytes(temp,(unsigned char *)&gCenFreq,4);
 327   1              
 328   1              readE2promStr(4,EE_IFFreq,temp);                                                                        //读取中频频率
 329   1              swapBytes(temp,(unsigned char *)&gIFFreq,4);
 330   1              
 331   1              gCenFreq -= gIFFreq;                                                                                            //中心频率减去中频频率值                
 332   1              gCenFreq /= gFreqStep; 
 333   1              gCenFreq += gIFOffset;
 334   1              
 335   1              if(gtestflag==1)
 336   1              {
 337   2                      return;
 338   2              }
 339   1              else
 340   1              {
 341   2                      readE2promStr(1,EE_SAWFNumer,&gSAWFNumer);                                              //读取声表温补分子
 342   2                      
 343   2                      value2 = (unsigned int)gSAWFNumer;
 344   2              
 345   2                      //readTemperatur();
 346   2                      temperature = gainCo;
 347   2                              
 348   2                      if (temperature < 0)
 349   2                      {
 350   3                              flag_sa = TRUE;
 351   3                              temperature = ~temperature + 1; 
 352   3                      }
 353   2                      else flag_sa = FALSE;
 354   2                      
 355   2                      value1 = value2 * (unsigned int)temperature;
 356   2              
 357   2                      readE2promStr(1,EE_SAWFDenomi,&gSAWFDenomi);                                                                    //读取声表温补分母
 358   2                      if(gSAWFDenomi == 0)
 359   2                      {
 360   3                              gSAWFDenomi = 100;
 361   3                      }
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 7   

 362   2                      value2 = (unsigned int)gSAWFDenomi;
 363   2              
 364   2                      value2 *= gFreqStep;
 365   2                      value1 /= value2;
 366   2      
 367   2                      value1 /= 2;
 368   2      
 369   2                      if (flag_sa)
 370   2                      {
 371   3                              gCenFreq -= (unsigned long)value1;
 372   3                      }
 373   2                      else
 374   2                      {
 375   3                              gCenFreq += (unsigned long)value1;
 376   3                      }
 377   2              }
 378   1              gCenFreq <<= 2;
 379   1              gCenFreq |= 0x100001L;
 380   1              progPLL( 'A', gCenFreq);                                //N-reg
 381   1      
 382   1              gCenFreq = gRefFreq;                                            //可变，可以是10M也可以是12M
 383   1              gCenFreq /= (unsigned long)gFreqStep;
 384   1              gCenFreq <<= 2;
 385   1              gCenFreq |= 0x100000L;
 386   1              progPLL( 'A', gCenFreq);                                //R-reg
 387   1              
 388   1              gCenFreq = F_reg;
 389   1              progPLL( 'C', gCenFreq);                                //F-reg
 390   1      
 391   1              
 392   1      }
 393          /*
 394          **********************************************************************************************************
             -******
 395          *                         温度补偿功放偏压值
 396          *
 397          * Description: 对功放偏压值进行重新设置 
 398          *
 399          * Arguments  : 无
 400          *
 401          * Returns    : 无
 402          **********************************************************************************************************
             -*******
 403          */
 404          void tempwritePAIq()
 405          {
 406   1              //int gainCo;
 407   1              unsigned int Iqnum;
 408   1      
 409   1          Iqnum =  gPAIqCo/10;
 410   1              gPAIqCoval = (int)Iqnum * gainCo;
 411   1              gPAIqCoval /= 10;
 412   1              gPAIqCoval /= 2;
 413   1              gPAIqact = gPAIq -  gPAIqCoval; 
 414   1              if(gPAIqact<0)
 415   1              {
 416   2                      gPAIqact = 0;
 417   2              }                                 
 418   1              writeDA1661(gPAIqact,'B');              
 419   1      }
 420          /*
 421          **********************************************************************************************************
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 8   

             -******
 422          *                         读取温度
 423          *
 424          * Description: 读取温度，定时执行，更新温度值 
 425          *
 426          * Arguments  : 无
 427          *
 428          * Returns    : 无
 429          **********************************************************************************************************
             -*******
 430          */
 431          void readTemperatur()
 432          {
 433   1              int value = 0;
 434   1      
 435   1              gpreRfTemp =  gcurRfTemp;
 436   1              
 437   1              IRcvStr(0x90,0x00,(unsigned char*)&value,2);    //读取温度，其中指针寄存器为00
 438   1              value >>= 7;
 439   1              gcurRfTemp = value;
 440   1      
 441   1              if(gtestflag==0)                                                                                        //不在调试状态下，使用实际温度
 442   1              {
 443   2                      gainCo = gcurRfTemp - 50;                                                               //0.5dB为步进故计算值要乘以2 
 444   2              }
 445   1              else if(gtestflag==2)
 446   1              {
 447   2                      gainCo = gtestRfTemp - 50;                                                              //0.5dB为步进故计算值要乘以2 
 448   2              }
 449   1      
 450   1      }
 451          /*
 452          **********************************************************************************************************
             -******
 453          *                         温度补偿
 454          *
 455          * Description: 根据读取的温度值，对衰减值和锁相环分别进行温补操作 
 456          *
 457          * Arguments  : 无
 458          *
 459          * Returns    : 无
 460          **********************************************************************************************************
             -*******
 461          */
 462          void tempCompensate() 
 463          {
 464   1              unsigned char numerator, denominator;
 465   1              int gainCotemp;
 466   1              unsigned char tmpAtt,bus;
 467   1      
 468   1              if( (softDownLoad == DOING)||(gtestflag==1) )
 469   1              {
 470   2                      return;
 471   2              }
 472   1              if( (rfPramModified == TRUE) || (gpreRfTemp != gcurRfTemp) )    //射频参数更改或温度有变化
 473   1              {
 474   2                      readE2promStr(1,EE_GainNumer,&numerator);                                       //增益温补系数分子
 475   2                      readE2promStr(1,EE_GainDenomi,&denominator);                            //增益温补系数分母
 476   2                      readE2promStr(1,EE_TEMP_VALUE,&gTempgain);                              //读取温度基准值
 477   2                      if( gTempgain > 16 ) 
 478   2                      {               
 479   3                              gTempgain = 9;
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 9   

 480   3                      }       
 481   2               
 482   2                      //gainCo = gainCo<<1;
 483   2                      gainCotemp = gainCo*numerator;
 484   2                      if(denominator == 0)
 485   2                      {
 486   3                              denominator = 100;
 487   3                      }
 488   2                      gainCotemp = gainCotemp/denominator;
 489   2                        
 490   2                      gainCotemp = gTempgain - gainCotemp;
 491   2                      if(gainCotemp < 0)
 492   2                      {
 493   3                              gAtttempval = 0;
 494   3                      }
 495   2                      else if(gainCotemp > 0x3F)
 496   2                      {
 497   3                              gAtttempval = 0x3F;
 498   3                      }
 499   2                      else
 500   2                      {
 501   3                              gAtttempval = (unsigned char)gainCotemp;
 502   3                      }
 503   2                      if((gRF_No&0xF0)==0)                                                    //取得通道号，上行or下行
 504   2                      {
 505   3                              bus = 0;
 506   3                      }
 507   2                      else
 508   2                      {
 509   3                              bus = 1;
 510   3                      }  
 511   2                      if(bus==0)
 512   2                      {
 513   3                              //上行，温补和增益调整、<＝15部分放在Att2－2U6；>15部分放在Att1－1U5                                                                            
 514   3                              if(gAtteVal<=15)                                                                                                   
 515   3                              {
 516   4                                      tmpAtt = gAtteVal<<1;                   //0.5dB步进需乘以2
 517   4                                      tmpAtt += gAtttempval;
 518   4                                      tmpAtt += gGainOffset;
 519   4                              }
 520   3                              else
 521   3                              {
 522   4                                      tmpAtt = gAtttempval + 30;                      //0.5dB步进需乘以2
 523   4                                      tmpAtt += gGainOffset;  
 524   4                              }
 525   3                      }
 526   2                      else
 527   2                      {
 528   3                              //下行，温补和增益调整放在Att2－2U6，增益设定值全部放在Att1－1U5
 529   3                              tmpAtt =  gAtttempval + gGainOffset ;
 530   3                      }
 531   2                      if(tmpAtt > 0x3F)
 532   2                      {
 533   3                              tmpAtt = 0x3F;
 534   3                      }                               
 535   2                      writeAtt2(tmpAtt);
 536   2                      gAtt2 = tmpAtt; 
 537   2                      watchdog();
 538   2                      writePLL();     
 539   2                      watchdog();
 540   2                      tempwritePAIq();                                                        //对功放偏压进行温度补偿
 541   2              }   
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 10  

 542   1              rfPramModified = FALSE;                                                 //射频参数修改标志      
 543   1      
 544   1      }
 545          /*
 546          *********************************************************************************************************
 547          *                         A/D转换
 548          *
 549          * Description: 根据给定的A/D转换通道，取得相应的A/D转换值
 550          *
 551          * Arguments  : channel  给定的通道号
 552          *
 553          * Returns    : value    转换结果
 554          *********************************************************************************************************
 555          */
 556          unsigned int readAD(unsigned char channel)
 557          {
 558   1              unsigned int value = 0; 
 559   1              unsigned int temp = 0;
 560   1              
 561   1              AD0INS  = channel;                                              //选择转换通道
 562   1              AD0MODA|= 0x10;                                                 //单次转换
 563   1              AD0MODB|= 0x20;                                                 //单次转换
 564   1              
 565   1              AD0CON = 0x05;                                                  //立即启动
 566   1              while(!AD0CON&0x08);                                    //等待转换完毕
 567   1      
 568   1              if(channel==1)
 569   1              {
 570   2                      value |= AD0DAT0R;                                      //右边字节，低位
 571   2                      temp  |= AD0DAT0L;                                      //左边字节，高位
 572   2              }
 573   1              else if(channel==2)
 574   1              {
 575   2                      value |= AD0DAT1R;
 576   2                      temp  |= AD0DAT1L;
 577   2              }
 578   1              else if(channel==8)
 579   1              {
 580   2                      value |= AD0DAT3R;
 581   2                      temp  |= AD0DAT3L;
 582   2              }
 583   1              else if (channel==16)
 584   1              {                                       
 585   2                      value |= AD0DAT4R;
 586   2                      temp  |= AD0DAT4L;
 587   2      
 588   2              }
 589   1          temp <<= 2;
 590   1              temp &= 0x0300;
 591   1              value &= 0x00FF;
 592   1              temp |= value;
 593   1              return temp;
 594   1      
 595   1      }
 596          /*
 597          *********************************************************************************************************
 598          *                         计算程序校验和
 599          *
 600          * Description: 读取flash中的代码，计算校验和
 601          *
 602          * Arguments  : 无
 603          *
C51 COMPILER V7.06   BRO20W_RFCONTROL                                                      04/24/2006 10:56:53 PAGE 11  

 604          * Returns    : 计算结果保存在全局变量all_checksum中
 605          *********************************************************************************************************
 606          */
 607          void execCheckSumQ()
 608          {
 609   1              unsigned char code *data pt_flash;      
 610   1              all_checksum = 0;
 611   1              for (pt_flash = 0x0000; pt_flash < 0x1D00; pt_flash++)
 612   1              {
 613   2                      all_checksum += *pt_flash;
 614   2                      watchdog();
 615   2              }
 616   1              for (pt_flash = 0x0000; pt_flash < 0xE300; pt_flash++)
 617   1              {
 618   2                      all_checksum += 0xFF;
 619   2                      watchdog();
 620   2              }
 621   1      }
 622          /*
 623          *********************************************************************************************************
 624          *                         上电复位主动发起命令
 625          *
 626          * Description: 主动发送一个下载确认命令，复位时发送
 627          *
 628          * Arguments  : 无
 629          *
 630          * Returns    : 无
 631          *********************************************************************************************************
 632          */
 633          void sendInitpacket()
 634          {       
 635   1              RxBuf[0] = 0x00;        //主控板地址
 636   1              RxBuf[1] = 8;           //长度
 637   1              RxBuf[2] = 0xA0;        //命令标识
 638   1              RxBuf[3] = 0x00;        //应答标志
 639   1              RxBuf[4] = 6;           //监控对象长度
 640   1              RxBuf[5] = 0xFD;
 641   1              RxBuf[6] = 0x0A;
 642   1              RxBuf[7] = 0x01;
 643   1              RxBuf[8] = 0x01;
 644   1              RxBuf[9] = 0x01;
 645   1      
 646   1              Data_len = 10;
 647   1      
 648   1              sendPkt();
 649   1      }
 650          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2372    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      45
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
