C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\OUTPUT\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE APP\main.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\my_project.ORC) 
                    -BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\main.lst) TABS(2) OBJECT(.\OUTPUT\main.obj)

line level    source

   1          
   2          /**-------------文件信息--------------------------------------------------------------------------------
   3          **文   件   名: main.c
   4          **创   建   人: 程莺红
   5          **修   改   人: 
   6          **最后修改日期: 2006年5月15日
   7          **最 新 版  本: V1.3
   8          **描        述: 主函数
   9          **
  10          **--------------历史版本信息----------------------------------------------------------------------------
  11          ** 创建人: 程莺红 
  12          ** 版  本: V1.2
  13          ** 日　期: 2006年3月31日
  14          ** 描　述: 原始版本
  15          **
  16          **--------------历史版本信息----------------------------------------------------------------------------
  17          ** 创建人: 程莺红 
  18          ** 版  本: V1.3
  19          ** 日　期: 2006年5月15日
  20          ** 描　述:1、 增加了串口超时判断；
  21          **
  22          *******************************************************************************************************
  23          
  24          **-------------版本改动信息----------------------------------------------------------------------------
  25          **
  26          ** 
  27          ** 日　期: 2010年5月20日
  28          ** 描　述:1、 增加了衰减器及其相关操作
  29          **
  30          ********************************************************************************************************/
  31          
  32          #define APP_GLOBALS
  33          
  34          #include <reg936.h>
  35          #include <stdio.h>
  36          #include <intrins.h>
  37          #include <string.h>   
  38          #include <SPI.h>
  39          #include <cpu.h>
  40          #include <serial.h>
  41          #include <task.h>
  42          #include <packet.h>
  43          #include <bro20W_RFcontrol.h>
  44          #include <bro20W_RFparam.h>
  45          #include <timer.h>
  46          #include <readad.h>
  47          #include <e2prom.h>
  48          //#include <math.h>
  49          
  50          static void ZhouQiFaSong5ms(void) small
  51          {
  52   1      #define TRIG_PLUS_BAUD    20  //20hz
  53   1      //const static unsigned char xdata txPaBuf[] = {0x00,0x40,0x55,0x02,0x00,0x40,0x66,0x02,0x00,0x40,0x77,0x0
             -2};  
C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 2   

  54   1        static unsigned char idx = 0,cycCnt = 0;
  55   1        static unsigned char xdata txPaBuf[] = {0x40,0x00,0x00,0x00,0x00,0x02};
  56   1        unsigned char state,check;
  57   1      
  58   1        if( ++cycCnt < 100/TRIG_PLUS_BAUD ) 
  59   1          return; 
  60   1        else
  61   1          cycCnt = 0;
  62   1      
  63   1        if ( __PlusSwitchState == CLOSE )return;
  64   1        
  65   1        if( idx == 0 )
  66   1        {
  67   2          txPaBuf[1] = __PlusReqAddr;
  68   2          txPaBuf[2] = (unsigned char)((__PlusReqPower&0x0f) + ((__PlusReqFreq<<4)&0x00f0));
  69   2          txPaBuf[3] = (unsigned char)(__PlusReqFreq>>4);
  70   2          check = 0;
  71   2          check^=txPaBuf[1];
  72   2          check^=txPaBuf[2];
  73   2          check^=txPaBuf[3];
  74   2          txPaBuf[4] = check;
  75   2        }
  76   1        
  77   1        state = (unsigned char)(txPaBuf[idx/8] & (1<<(idx%8)));
  78   1      
  79   1        if(++idx/8>=sizeof(txPaBuf))
  80   1        {
  81   2          idx = 0;
  82   2          __PlusSwitchState = CLOSE;
  83   2        }
  84   1        
  85   1        if(state!=0)
  86   1        {
  87   2      #ifdef NEW_PLAD   
  88   2          writeAD5314(gDAoutB,'B');
  89   2          writeAD5314(gDAoutC,'C');     
  90   2      #endif    
  91   2          RFswitch = 0;
  92   2        }
  93   1        else
  94   1        {
  95   2      #ifdef NEW_PLAD
  96   2          writeAD5314(0,'B');
  97   2          writeAD5314(0,'C'); 
  98   2      #endif    
  99   2          RFswitch = 1;     
 100   2        }   
 101   1      }
 102          
 103          /*
 104          *********************************************************************************************************
 105          *                         主函数
 106          *
 107          * Description: 初始化系统后，进入主循环，按顺序执行各个任务
 108          *
 109          * Arguments  : 无
 110          *
 111          * Returns    : 无
 112          *********************************************************************************************************
 113          */
 114          void main(void) small
 115          {
C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 3   

 116   1        InitCpu();                  // 和本应用系统相关的初始化
 117   1        InitSerial();               //串口初始化
 118   1        InitSPI();                  //初始化SPI总线
 119   1        InitRF();                 //初始化模块参数
 120   1        InitTimer1();
 121   1        sendInitpacket();
 122   1        DwnldSoft1m_time = getTime();
 123   1      
 124   1        EA = 0;
 125   1        TimerCallback = (void*)ZhouQiFaSong5ms;
 126   1        EA = 1;
 127   1        
 128   1        while(1)
 129   1        {     
 130   2          if (getTime()- DwnldSoft1m_time >= DwnldSoftTimeOut)
 131   2          {
 132   3            softDownLoad = UNDO;
 133   3          }
 134   2          TaskRoutine();       //定时执行
 135   2          TaskHandlePkt();    //串口通讯处理
 136   2        }
 137   1      }
 138          /*
 139          *********************************************************************************************************
 140          *                         新包处理任务
 141          *
 142          * Description: 根据邮箱信息做相应处理
 143          *
 144          * Arguments  : 
 145          *        parameter  指针，指向提供给任务的相关参数
 146          *
 147          * Returns    : 无
 148          *********************************************************************************************************
 149          */
 150          void TaskHandlePkt() 
 151          {
 152   1        unsigned char bPulse = FALSE;
 153   1        
 154   1        if(pack_valid == 1)
 155   1        { 
 156   2      
 157   2      //      RDE = 1;
 158   2      //      SM2 = 0;
 159   2      
 160   2          if(ack_flag==0)
 161   2          {
 162   3            watchdog();
 163   3            execute_cmd();            //没有错误则执行相应的命令
 164   3          }
 165   2          if(ack_flag!=0)
 166   2          //else
 167   2          {                   //组织错误包
 168   3            RxBuf[3] = ack_flag;        //置应答标志  
 169   3            Data_len = RxBuf[1] + 2;      //包中的长度＋地址（1字节）＋长度字节本身（1字节）
 170   3          }
 171   2          
 172   2          watchdog();
 173   2          while( OPEN == __PlusSwitchState ){bPulse = TRUE;watchdog();};
 174   2          
 175   2          if(PktHandle2S_time < PktHandleTimeOut || TRUE == bPulse)
 176   2          {           //没有超时则发包
 177   3            sendPkt();
C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 4   

 178   3          }
 179   2          else
 180   2          {           //否则设置数据包无效
 181   3            pack_valid = 0;
 182   3          }                         
 183   2        }
 184   1      }
 185          
 186          /*
 187          *********************************************************************************************************
 188          *                         定时执行任务
 189          *
 190          * Description: 在需要时查询各个系统参数，有异常时处理告警信息
 191          *
 192          * Arguments  : 
 193          *        parameter  指针，指向提供给任务的相关参数
 194          *
 195          * Returns    : 无
 196          *********************************************************************************************************
 197          */
 198          void TaskRoutine()
 199          {
 200   1        watchdog();
 201   1        if( softDownLoad == UNDO || softDownLoad == DONE )
 202   1        {
 203   2          if(Task100MS_time < getTime())     //add by  dw 20090603 
 204   2          {
 205   3            Task100MS_time += DELAY100MS;
 206   3            Switch_clock();
 207   3          }
 208   2          if(Task5S_time < getTime())
 209   2          {
 210   3            Task5S_time += DELAY5S;
 211   3            TaskRunPer5s();
 212   3          }
 213   2          if(Task30S_time < getTime())
 214   2          {
 215   3            Task30S_time += DELAY30S;
 216   3            TaskRunPer30s();
 217   3          }
 218   2        }
 219   1      }
 220          
 221          /*
 222          *********************************************************************************************************
 223          *                         定时执行对ADF4350的内外时钟的检测切换 
 224          *
 225          * Description: 在TaskRoutine中调用，每100MS 
 226          *
 227          * Arguments  : 无
 228          *
 229          * Returns    : 无
 230          *********************************************************************************************************
 231          */
 232          void Switch_clock()                  //add by  dw 20090603 
 233          {
 234   1          unsigned int data vcc_in = 0;
 235   1        unsigned char data i;
 236   1        if( softDownLoad != DOING )
 237   1          {
 238   2            //对AD转换后的电压进行判别，并对P2.6输出一个电平     
 239   2            //watchdog();
C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 5   

 240   2            for( i = 0; i < 8; i++ )
 241   2            {
 242   3              //vcc_in += readAD(CHANNEL_2);
 243   3              vcc_in += readAD(CHANNEL_6);
 244   3            }
 245   2            //ADCON0 = 0x01;              //关闭转换，以防止出现的管脚相互影响现象。add by dw   20090623
 246   2            
 247   2            vcc_in >>= 3;
 248   2            
 249   2            if( vcc_in < 62  )              //62 = (0.2  / 3.3) * 2 >>10
 250   2              V33C = 0;
 251   2            else
 252   2              V33C = 1;
 253   2          }
 254   1      }
 255          /*
 256          *********************************************************************************************************
 257          *                         定时执行告警信息更新
 258          *
 259          * Description: 在TaskRoutine中调用，每5秒一次
 260          *
 261          * Arguments  : 无
 262          *
 263          * Returns    : 无
 264          *********************************************************************************************************
 265          */
 266          void TaskRunPer5s()
 267          {
 268   1        if( softDownLoad != DOING )                     //软件下载时
 269   1        {
 270   2          updateAlmInfo();                        //更新告警信息
 271   2        }
 272   1      }
 273          /*
 274          *********************************************************************************************************
 275          *                         定时执行温度补偿    读取温度值
 276          *
 277          * Description: 在TaskRoutine中调用，每30秒一次
 278          *
 279          * Arguments  : 无
 280          *
 281          * Returns    : 无
 282          *********************************************************************************************************
 283          */
 284          void TaskRunPer30s() 
 285          {
 286   1        if( softDownLoad != DOING )             //软件下载时，不发告警
 287   1        {
 288   2                                      //若动作了射频开关，则需要对衰减器和锁相环重新进行操作
 289   2          readTemperatur();               //更新温度记录
 290   2          
 291   2          //功放打开后周期进行温度补偿操作
 292   2          if(gRFSW == OPEN)
 293   2          {
 294   3            gPALimCompensate();
 295   3            writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 296   3          }
 297   2          //  if((rfPramModified == TRUE) || (gpreRfTemp != gcurRfTemp) ) //射频参数更改或温度有变化
 298   2        //  {
 299   2            //tempCompensate();               //温度补偿
 300   2        //  }
 301   2        watchdog();
C51 COMPILER V9.51   MAIN                                                                  10/30/2014 16:21:17 PAGE 6   

 302   2        }  
 303   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    532    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    388    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45       1
   IDATA SIZE       =     22    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
