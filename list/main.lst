C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\OUTPUT\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE APP\main.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\my_project.ORC) 
                    -BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\main.lst) TABS(2) OBJECT(.\OUTPUT\main.obj)

line level    source

   1          
   2          /**-------------文件信息--------------------------------------------------------------------------------
   3          **文   件   名: main.c
   4          **创   建   人: 程莺红
   5          **修   改   人: 
   6          **最后修改日期: 2006年5月15日
   7          **最 新 版  本: V1.3
   8          **描        述: 主函数
   9          **
  10          **--------------历史版本信息----------------------------------------------------------------------------
  11          ** 创建人: 程莺红 
  12          ** 版  本: V1.2
  13          ** 日　期: 2006年3月31日
  14          ** 描　述: 原始版本
  15          **
  16          **--------------历史版本信息----------------------------------------------------------------------------
  17          ** 创建人: 程莺红 
  18          ** 版  本: V1.3
  19          ** 日　期: 2006年5月15日
  20          ** 描　述:1、 增加了串口超时判断；
  21          **
  22          *******************************************************************************************************
  23          
  24          **-------------版本改动信息----------------------------------------------------------------------------
  25          **
  26          ** 
  27          ** 日　期: 2010年5月20日
  28          ** 描　述:1、 增加了衰减器及其相关操作
  29          **
  30          ********************************************************************************************************/
  31          
  32          #define APP_GLOBALS
  33          
  34          #include <reg936.h>
  35          #include <stdio.h>
  36          #include <intrins.h>
  37          #include <string.h>   
  38          #include <SPI.h>
  39          #include <cpu.h>
  40          #include <serial.h>
  41          #include <task.h>
  42          #include <packet.h>
  43          #include <bro20W_RFcontrol.h>
  44          #include <bro20W_RFparam.h>
  45          #include <timer.h>
  46          #include <readad.h>
  47          #include <e2prom.h>
  48          //#include <math.h>
  49          
  50          static void ZhouQiFaSong5ms(void) small
  51          {
  52   1      #define TRIG_PLUS_BAUD    20  //20hz
  53   1      //const static unsigned char xdata txPaBuf[] = {0x00,0x40,0x55,0x02,0x00,0x40,0x66,0x02,0x00,0x40,0x77,0x0
             -2};  
C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 2   

  54   1        static unsigned char idx = 0,cycCnt = 0;
  55   1        static unsigned char xdata txPaBuf[] = {0x40,0x00,0x00,0x00,0x00,0x02};
  56   1        unsigned char state,check;
  57   1      
  58   1        if( ++cycCnt < 100/TRIG_PLUS_BAUD ) 
  59   1          return; 
  60   1        else
  61   1          cycCnt = 0;
  62   1      
  63   1        if ( __PlusSwitchState == CLOSE )return;
  64   1        
  65   1        if( idx == 0 )
  66   1        {
  67   2          txPaBuf[1] = __PlusReqAddr;
  68   2          txPaBuf[2] = (unsigned char)((__PlusReqPower&0x0f) + ((__PlusReqFreq<<4)&0x00f0));
  69   2          txPaBuf[3] = (unsigned char)(__PlusReqFreq>>4);
  70   2          check = 0;
  71   2          check^=txPaBuf[1];
  72   2          check^=txPaBuf[2];
  73   2          check^=txPaBuf[3];
  74   2          txPaBuf[4] = check;
  75   2        }
  76   1        
  77   1        state = (unsigned char)(txPaBuf[idx/8] & (1<<(idx%8)));
  78   1      
  79   1        if(++idx/8>=sizeof(txPaBuf))
  80   1        {
  81   2          idx = 0;
  82   2          __PlusSwitchState = CLOSE;
  83   2        }
  84   1        
  85   1        if(state!=0)
  86   1        {
  87   2          RFswitch = 0;
  88   2        }
  89   1        else
  90   1        {
  91   2          RFswitch = 1;     
  92   2        }   
  93   1      }
  94          
  95          /*
  96          *********************************************************************************************************
  97          *                         主函数
  98          *
  99          * Description: 初始化系统后，进入主循环，按顺序执行各个任务
 100          *
 101          * Arguments  : 无
 102          *
 103          * Returns    : 无
 104          *********************************************************************************************************
 105          */
 106          void main(void) small
 107          {
 108   1        InitCpu();                  // 和本应用系统相关的初始化
 109   1        InitSerial();               //串口初始化
 110   1        InitSPI();                  //初始化SPI总线
 111   1        InitRF();                 //初始化模块参数
 112   1        InitTimer1();
 113   1        sendInitpacket();
 114   1        DwnldSoft1m_time = getTime();
 115   1      
C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 3   

 116   1        EA = 0;
 117   1        TimerCallback = (void*)ZhouQiFaSong5ms;
 118   1        EA = 1;
 119   1        
 120   1        while(1)
 121   1        {     
 122   2          if (getTime()- DwnldSoft1m_time >= DwnldSoftTimeOut)
 123   2          {
 124   3            softDownLoad = UNDO;
 125   3          }
 126   2          TaskRoutine();       //定时执行
 127   2          TaskHandlePkt();    //串口通讯处理
 128   2        }
 129   1      }
 130          /*
 131          *********************************************************************************************************
 132          *                         新包处理任务
 133          *
 134          * Description: 根据邮箱信息做相应处理
 135          *
 136          * Arguments  : 
 137          *        parameter  指针，指向提供给任务的相关参数
 138          *
 139          * Returns    : 无
 140          *********************************************************************************************************
 141          */
 142          void TaskHandlePkt() 
 143          {
 144   1        unsigned char bPulse = FALSE;
 145   1        
 146   1        if(pack_valid == 1)
 147   1        { 
 148   2      
 149   2      //      RDE = 1;
 150   2      //      SM2 = 0;
 151   2      
 152   2          if(ack_flag==0)
 153   2          {
 154   3            watchdog();
 155   3            execute_cmd();            //没有错误则执行相应的命令
 156   3          }
 157   2          if(ack_flag!=0)
 158   2          //else
 159   2          {                   //组织错误包
 160   3            RxBuf[3] = ack_flag;        //置应答标志  
 161   3            Data_len = RxBuf[1] + 2;      //包中的长度＋地址（1字节）＋长度字节本身（1字节）
 162   3          }
 163   2          
 164   2          watchdog();
 165   2          while( OPEN == __PlusSwitchState ){bPulse = TRUE;watchdog();};
 166   2          
 167   2          if(PktHandle2S_time < PktHandleTimeOut || TRUE == bPulse)
 168   2          {           //没有超时则发包
 169   3            sendPkt();
 170   3          }
 171   2          else
 172   2          {           //否则设置数据包无效
 173   3            pack_valid = 0;
 174   3          }                         
 175   2        }
 176   1      }
 177          
C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 4   

 178          /*
 179          *********************************************************************************************************
 180          *                         定时执行任务
 181          *
 182          * Description: 在需要时查询各个系统参数，有异常时处理告警信息
 183          *
 184          * Arguments  : 
 185          *        parameter  指针，指向提供给任务的相关参数
 186          *
 187          * Returns    : 无
 188          *********************************************************************************************************
 189          */
 190          void TaskRoutine()
 191          {
 192   1        watchdog();
 193   1        if( softDownLoad == UNDO || softDownLoad == DONE )
 194   1        {
 195   2          if(Task100MS_time < getTime())     //add by  dw 20090603 
 196   2          {
 197   3            Task100MS_time += DELAY100MS;
 198   3            Switch_clock();
 199   3          }
 200   2          if(Task5S_time < getTime())
 201   2          {
 202   3            Task5S_time += DELAY5S;
 203   3            TaskRunPer5s();
 204   3          }
 205   2          if(Task30S_time < getTime())
 206   2          {
 207   3            Task30S_time += DELAY30S;
 208   3            TaskRunPer30s();
 209   3          }
 210   2        }
 211   1      }
 212          
 213          /*
 214          *********************************************************************************************************
 215          *                         定时执行对ADF4350的内外时钟的检测切换 
 216          *
 217          * Description: 在TaskRoutine中调用，每100MS 
 218          *
 219          * Arguments  : 无
 220          *
 221          * Returns    : 无
 222          *********************************************************************************************************
 223          */
 224          void Switch_clock()                  //add by  dw 20090603 
 225          {
 226   1          unsigned int data vcc_in = 0;
 227   1        unsigned char data i;
 228   1        if( softDownLoad != DOING )
 229   1          {
 230   2            //对AD转换后的电压进行判别，并对P2.6输出一个电平     
 231   2            //watchdog();
 232   2            for( i = 0; i < 8; i++ )
 233   2            {
 234   3              //vcc_in += readAD(CHANNEL_2);
 235   3              vcc_in += readAD(CHANNEL_6);
 236   3            }
 237   2            //ADCON0 = 0x01;              //关闭转换，以防止出现的管脚相互影响现象。add by dw   20090623
 238   2            
 239   2            vcc_in >>= 3;
C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 5   

 240   2            
 241   2            if( vcc_in < 62  )              //62 = (0.2  / 3.3) * 2 >>10
 242   2              V33C = 0;
 243   2            else
 244   2              V33C = 1;
 245   2          }
 246   1      }
 247          /*
 248          *********************************************************************************************************
 249          *                         定时执行告警信息更新
 250          *
 251          * Description: 在TaskRoutine中调用，每5秒一次
 252          *
 253          * Arguments  : 无
 254          *
 255          * Returns    : 无
 256          *********************************************************************************************************
 257          */
 258          void TaskRunPer5s()
 259          {
 260   1        if( softDownLoad != DOING )                     //软件下载时
 261   1        {
 262   2          updateAlmInfo();                        //更新告警信息
 263   2        }
 264   1      }
 265          /*
 266          *********************************************************************************************************
 267          *                         定时执行温度补偿    读取温度值
 268          *
 269          * Description: 在TaskRoutine中调用，每30秒一次
 270          *
 271          * Arguments  : 无
 272          *
 273          * Returns    : 无
 274          *********************************************************************************************************
 275          */
 276          void TaskRunPer30s() 
 277          {
 278   1        if( softDownLoad != DOING )             //软件下载时，不发告警
 279   1        {
 280   2                                      //若动作了射频开关，则需要对衰减器和锁相环重新进行操作
 281   2          readTemperatur();               //更新温度记录
 282   2          
 283   2          //功放打开后周期进行温度补偿操作
 284   2          if(gRFSW == OPEN)
 285   2          {
 286   3            gPALimCompensate();
 287   3            writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 288   3          }
 289   2          //  if((rfPramModified == TRUE) || (gpreRfTemp != gcurRfTemp) ) //射频参数更改或温度有变化
 290   2        //  {
 291   2            //tempCompensate();               //温度补偿
 292   2        //  }
 293   2        watchdog();
 294   2        }  
 295   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    492    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    388    ----
C51 COMPILER V9.51   MAIN                                                                  10/21/2014 13:18:03 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45       1
   IDATA SIZE       =     22    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
