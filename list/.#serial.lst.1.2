C51 COMPILER V7.06   SERIAL                                                                04/24/2006 10:56:54 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE SERIAL
OBJECT MODULE PLACED IN .\OUTPUT\serial.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE drive\serial.c BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRI
                    -NT(.\list\serial.lst) OBJECT(.\OUTPUT\serial.obj)

stmt level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: serial.c
   3          **创   建   人: 程莺红
   4          **修   改   人: 
   5          **最后修改日期: 2006年3月31日
   6          **最 新 版  本: V1.2
   7          **描        述: 串口初始化、接收和发送中断处理程序
   8                                          
   9          **
  10          **--------------历史版本信息----------------------------------------------------------------------------
  11          ** 创建人: 程莺红 
  12          ** 版  本: V1.2
  13          ** 日　期: 2006年3月31日
  14          ** 描　述: 原始版本
  15          **
  16          ********************************************************************************************************/
  17          
  18          #include <reg938.h>
  19          #include <serial.h>
  20          #include <string.h>
  21          #include <packet.h>
  22          #include <bro20W_RFcontrol.h>
  23          
  24                                                                                          
  25          
  26          /*
  27          *********************************************************************************************************
  28          *                         串口初始化
  29          *
  30          * Description: 串口初始化以及与串口接收、发送相关参数
  31          *
  32          * Arguments  : 无
  33          *
  34          * Returns    : 无
  35          *********************************************************************************************************
  36          */
  37          void InitSerial()               
  38          {
  39   1              // 初始化串口   
  40   1                                              //485接收有效，发送禁止
  41   1              Rx_state = STA_ADDRESS1;        //初始化接收状态,第一个字节为
  42   1              pack_valid = 0;
  43   1          RDE = 0;
  44   1      
  45   1              //9位数据模式
  46   1              SCON  = 0xF0;                           //串口模式3，使用多机通信，接收使能
  47   1              BRGCON= 0x00;                           //波特率发生器使能
  48   1              BRGR1 = 0x04;                           //波特率9600bit/s，采用11.0592的晶振 
  49   1              BRGR0 = 0x70;
  50   1              SSTAT = 0xE0;                           //选择独立的RX/TX中断
  51   1              BRGCON= 0x03;                           //启动UART的波特率发生器 
  52   1      
  53   1              //8位数据模式
  54   1      /*      SCON  = 0x50;                           //串口模式3，使用多机通信，接收使能
C51 COMPILER V7.06   SERIAL                                                                04/24/2006 10:56:54 PAGE 2   

  55   1              BRGCON= 0x00;                           //波特率发生器使能
  56   1              //BRGR1 = 0x02;                         //波特率9600bit/s，采用cpu内部晶振 
  57   1              //BRGR0 = 0xF0;
  58   1              
  59   1      
  60   1              BRGR1 = 0x04;                           //波特率9600bit/s，采用外部11.0592的晶振 
  61   1              BRGR0 = 0x70;
  62   1      
  63   1              SSTAT = 0xA0;                           //选择独立的RX/TX中断
  64   1              BRGCON= 0x03;                           //启动UART的波特率发生器 
  65   1      */      
  66   1              ESR = 1;                                        //串口RI使能
  67   1              EST = 1;                                        //串口TI使能
  68   1      
  69   1      }
  70          
  71          /*
  72          *********************************************************************************************************
  73          *                         串口发送中断服务程序
  74          *
  75          * Description: 实现串口的发送，有独立的波特率发生器
  76          *
  77          * Arguments  : 无
  78          *
  79          * Returns    : 无
  80          *********************************************************************************************************
  81          */
  82          void SerialSend_ISR() small interrupt 13 
  83          {    
  84   1              if(TI)
  85   1              {
  86   2                      TI = 0;
  87   2                      /*commet test for uart*/
  88   2                      TB8 = 0x00;                                     //开始发送数据字节，TB8必须为0
  89   2                      Tx_ptr++;
  90   2                      if(Tx_ptr<(TxBuf[4]+7))
  91   2                      {
  92   3                              SBUF = TxBuf[Tx_ptr];
  93   3                      }
  94   2                      else
  95   2                      {
  96   3                              RDE =  0;
  97   3                      } 
  98   2              }               
  99   1      }
 100          
 101          /*
 102          *********************************************************************************************************
 103          *                         串口接收中断服务程序
 104          *
 105          * Description: 实现串口的接收，有独立的波特率发生器
 106          *
 107          * Arguments  : 无
 108          *
 109          * Returns    : 无
 110          *********************************************************************************************************
 111          */
 112          void SerialRcv_ISR() small interrupt 4 
 113          {    
 114   1             
 115   1              unsigned char Rx_byte;
 116   1              EA = 0;                                                                                         //关中断
C51 COMPILER V7.06   SERIAL                                                                04/24/2006 10:56:54 PAGE 3   

 117   1              if(RI)
 118   1              {               
 119   2                      RI = 0;                                                 
 120   2                      Rx_byte = SBUF;
 121   2                      switch(Rx_state)
 122   2                      {
 123   3                              case STA_ADDRESS1:
 124   3                                      if((Rx_byte==gRF_No)||(Rx_byte==0xFE))//接收到的地址为本机地址或广播地址
 125   3                                      {
 126   4                                              Rx_state = STA_INIT1;                           
 127   4                                              SM2 = 0;        
 128   4                                      }
 129   3                                      else                                                                    //非本模块数据，则不接收
 130   3                                      {
 131   4                                              Rx_state = STA_ADDRESS1;
 132   4                                      }
 133   3                                      break;
 134   3                              case STA_INIT1:                                                         //包起始第一个字节
 135   3                                      if(Rx_byte==SYNC1)
 136   3                                      {
 137   4                                              Rx_state = STA_INIT2;   
 138   4                                      }
 139   3                                      else                                                                    //非本模块数据，则不接收
 140   3                                      {
 141   4                                              Rx_state = STA_ADDRESS1;
 142   4                                      }  
 143   3                                      break;
 144   3                              case STA_INIT2:                                                         //包起始第二个字节
 145   3                                      if(Rx_byte==SYNC2)
 146   3                                      {
 147   4                                              Rx_state = STA_ADDRESS2;        
 148   4                                      }
 149   3                                      else                                                                    //非本模块数据，则不接收
 150   3                                      {
 151   4                                              Rx_state = STA_ADDRESS1;
 152   4                                      } 
 153   3                                      break; 
 154   3                              case STA_ADDRESS2:                                                      //模块地址或者广播地址
 155   3                                      if((Rx_byte==gRF_No)||(Rx_byte==0xFE))
 156   3                                      {
 157   4                                              Rx_state = STA_PACKSIZE;
 158   4                                              Rx_chksum = Rx_byte;                            //校验和为异或校验
 159   4                                              RxBuf[0] = Rx_byte;     
 160   4                                      }
 161   3                                      else                                                                    //非本模块数据，则不接收
 162   3                                      {
 163   4                                              Rx_state = STA_ADDRESS1;
 164   4                                      }
 165   3                                      break;
 166   3                              case STA_PACKSIZE:                                                      //数据单元长度
 167   3      
 168   3                                       Rx_chksum ^= Rx_byte;
 169   3                                       RxBuf[1] = Rx_byte;
 170   3                                       if(Rx_byte)
 171   3                                       {
 172   4                                              Rx_state = STA_CMD;     
 173   4                                       }      
 174   3                                       else                                                                   //若数据长度为空，则回到初始化状态，不接收
 175   3                                       {
 176   4                                               Rx_state = STA_ADDRESS1;       
 177   4                                       }
 178   3                                       break;
C51 COMPILER V7.06   SERIAL                                                                04/24/2006 10:56:54 PAGE 4   

 179   3                              case STA_CMD:                                                           //数据单元中的命令标识，内部命令固定为0xA0
 180   3                                      if(Rx_byte==FCT_CMD)
 181   3                                      {
 182   4                                              Rx_state = STA_ACK;
 183   4                                              RxBuf[2] = Rx_byte;
 184   4                                              Rx_chksum ^= Rx_byte;
 185   4                                      }
 186   3                                      else                                                                    //若不是内部命令0xA0则不响应
 187   3                                      {
 188   4                                              Rx_state = STA_ADDRESS1;
 189   4                                      }
 190   3                                      break;
 191   3                              case STA_ACK:                                                           //数据单元中的应答标志
 192   3                                      if(Rx_byte==ACK)
 193   3                                      {
 194   4                                              Rx_state = STA_OL;
 195   4                                              Rx_chksum ^= Rx_byte;
 196   4                                              RxBuf[3] = 0x00;                                        //回复包的校验和设置为0
 197   4                                              ack_flag = 0;
 198   4                                      }
 199   3                                      else
 200   3                                      {
 201   4                                              Rx_state = STA_ADDRESS1;
 202   4                                      }
 203   3                                      break;
 204   3                              case   STA_OL:                                                          //监控对象长度                                                  
 205   3                                       Rx_chksum ^= Rx_byte;
 206   3                                       RxBuf[4] = Rx_byte;
 207   3                                       if(Rx_byte)
 208   3                                       {
 209   4                                              Rx_state = STA_OID1;    
 210   4                                       }      
 211   3                                       else                                                                   
 212   3                                       {
 213   4                                              Rx_state = STA_ADDRESS1;                
 214   4                                       }
 215   3                                       break;
 216   3                              case  STA_OID1:                                                         //监控对象标号
 217   3                                       Rx_chksum ^= Rx_byte;
 218   3                                       RxBuf[5] = Rx_byte;
 219   3                                       Rx_state = STA_OID2;   
 220   3                                       break;
 221   3                              case  STA_OID2:                                                         //监控对象标号
 222   3                                       Rx_chksum ^= Rx_byte;
 223   3                                       RxBuf[6] = Rx_byte;
 224   3                                       Rx_ptr = 7;
 225   3                                       Rx_state = STA_OC;     
 226   3                                       break;
 227   3      
 228   3                              case STA_OC:                                                            //监控对象内容
 229   3                                       Rx_chksum ^= Rx_byte;
 230   3                                       RxBuf[Rx_ptr] = Rx_byte;
 231   3                                       Rx_ptr++;
 232   3                                       if((Rx_ptr-4)== RxBuf[4])                              //监控对象内容接收完毕
 233   3                                       {
 234   4                                              Rx_state = STA_CHKSUM;          
 235   4                                       }
 236   3                                       if(Rx_ptr>(RxBuf[1]+2))
 237   3                                       {
 238   4                                              Rx_state = STA_ADDRESS1;
 239   4                                              pack_valid = 1;
 240   4                                              RDE = 1;
C51 COMPILER V7.06   SERIAL                                                                04/24/2006 10:56:54 PAGE 5   

 241   4                                              ack_flag = LEN_ERR;                                     //长度错        
 242   4                                              SM2 = 1;
 243   4                                       }
 244   3                                       break;
 245   3                              case STA_CHKSUM:                                                        //接收到数据的校验和
 246   3                                      if(Rx_byte!=Rx_chksum)
 247   3                                      {
 248   4                                              ack_flag = DEFSUM_ERR;          
 249   4                                      }
 250   3                                      Rx_state = STA_ADDRESS1;                                
 251   3                                      pack_valid = 1;
 252   3                                      RDE = 1;
 253   3                                      SM2 = 1;
 254   3                                      break;
 255   3                              default:                                                                        //重新开始接受下一个包
 256   3                                      Rx_state = STA_ADDRESS1;
 257   3                                      break;  
 258   3                      } 
 259   2              }       
 260   1                                                                                                                      //485发送有效，接收禁止
 261   1              EA = 1;                                                                                         //开中断
 262   1      }
 263          
 264          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    536    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
