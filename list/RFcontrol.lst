C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE RFCONTROL
OBJECT MODULE PLACED IN .\OUTPUT\RFcontrol.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE APP\RFcontrol.c BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PR
                    -INT(.\list\RFcontrol.lst) OBJECT(.\OUTPUT\RFcontrol.obj)

stmt level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: RFcontrol.c
   3          **创   建   人: 程莺红
   4          **修   改   人: 
   5          **最后修改日期: 2006年3月17日
   6          **最 新 版  本: V1.4
   7          **描        述: 完成射频板的射频初始化以及操作
   8          **
   9          **--------------历史版本信息----------------------------------------------------------------------------
  10          ** 创建人: 程莺红 
  11          ** 版  本: V1.2
  12          ** 日　期: 2006年2月21日
  13          ** 描　述: 原始版本
  14          **
  15          **------------------------------------------------------------------------------------------------------
  16          ** 修改人: 程莺红 
  17          ** 版  本: V1.3
  18          ** 日　期: 2006年3月15日
  19          ** 描　述: 增加了温补基准值的范围判断
  20          **
  21          **------------------------------------------------------------------------------------------------------
  22          ** 修改人: 程莺红 
  23          ** 版  本: V1.4
  24          ** 日　期: 2006年3月17日
  25          ** 描　述: 对声表分母为零时进行特殊处理
  26          **
  27          ********************************************************************************************************/
  28          
  29          #include <reg938.h>
  30          #include <string.h>
  31          #include <intrins.h>
  32          #include <i2c.h>
  33          #include <math.h>
  34          #include <bro20W_RFcontrol.h>
  35          #include <SPI.h>
  36          #include <packet.h>
  37          #include <task.h>
  38          #include <bro20W_RFparam.h>
  39          #include <serial.h>
  40          #include <timer.h>
  41          #include <e2prom.h>
  42          #include <readad.h>
  43          
  44          /*
  45          *********************************************************************************************************
  46          *                         射频参数初始化
  47          *
  48          * Description: 初始化RF模块的各类射频参数以及与系统相关的其余参数变量
  49          *
  50          * Arguments  : 无
  51          *
  52          * Returns    : 无
  53          *********************************************************************************************************
  54          */
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 2   

  55          void InitRF()
  56          {
  57   1              unsigned char temp[10];
  58   1              unsigned char bus;
  59   1              //sendInitpacket();
  60   1      
  61   1              switchRF(0);                                                                    //上电先关功放
  62   1              switchPA(0);                                                                    //上电先关射频
  63   1      
  64   1              rfPramModified = FALSE;                                                 //射频参数修改标志      
  65   1              Task5S_time = getTime() + DELAY5S;                              //初始化例行任务初始时间
  66   1              Task30S_time= getTime() + DELAY30S;
  67   1              LD = 1;
  68   1              LE1 = 0;
  69   1              LE2 =0;
  70   1              LE3 =1;
  71   1              softDownLoad = UNDO;                                                    //初始化为非下载状态
  72   1              ack_flag = NO_ERR;                                                              //初始化应答标志
  73   1              
  74   1              readE2promStr(1,EE_RF_No,&gRF_No);                              //读取射频模块地址
  75   1              readE2promStr(1,EE_RFSW,&gRFSW);                                //射频开关
  76   1              readE2promStr(1,EE_PASW,&gPASW);                                //功放开关
  77   1      
  78   1              gtestflag = 0;                                                                  //初始化测试状态
  79   1              gtestRfTemp = 50;                                                               //初始化测试温度值
  80   1              gpreRfTemp = 50;                                                                //初始化温度状态
  81   1              gcurRfTemp = 50;
  82   1              gAtttempval = 0;
  83   1              
  84   1              switchRF(gRFSW);
  85   1              switchPA(gPASW);
  86   1      
  87   1              readE2promStr(2,EE_PALim,temp);                                 //写限幅值DA,A通道                                              
  88   1              swapBytes(temp, (unsigned char *)&gPALim,2);
  89   1              writeDA1661(gPALim,'A');
  90   1              watchdog();
  91   1      
  92   1              readE2promStr(2,EE_PAIq,temp);                                  //写功放偏压DA，B通道                                                   
  93   1              swapBytes(temp, (unsigned char *)&gPAIq,2);
  94   1              if(gPAIq<0)
  95   1              {
  96   2                      gPAIq = 0;
  97   2              }
  98   1              writeDA1661(gPAIq,'B');
  99   1              watchdog();
 100   1              readE2promStr(2,EE_PAIqCo,temp);                                //读偏压温补系数                                                
 101   1              swapBytes(temp, (unsigned char *)&gPAIqCo,2);
 102   1      
 103   1              if((gRF_No&0xF0)==0)                                                    //取得通道号，上行or下行
 104   1              {
 105   2                      bus = 0;
 106   2              }
 107   1              else
 108   1              {
 109   2                      bus = 1;
 110   2              }  
 111   1              delay(3);
 112   1      
 113   1              readE2promStr(1,EE_AtteVal,&gAtteVal);                  //增益设定值
 114   1              readE2promStr(1,EE_GainOffset,&gGainOffset);    //增益调整值
 115   1              writeAttenuator(bus,gAtteVal);  
 116   1              writeLM75(0x90,0x00,2);                                                  //选择指针为配置寄存器
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 3   

 117   1      
 118   1              readE2promStr(1,EE_PAProtectLim,&gPAProtecttLim);//写功放保护温度门限
 119   1              writeLM75(0x03,gPAProtecttLim,3);       
 120   1              
 121   1              readE2promStr(1,EE_PAResetLim,&gPAResetLim);     //写功放重启温度门限
 122   1              writeLM75(0x02,gPAResetLim,3);  
 123   1      
 124   1              watchdog();
 125   1              readTemperatur();
 126   1              writePLL();                                                                             
 127   1              tempCompensate();                                                               //温度补偿
 128   1              execCheckSumQ();                                                                //初始化计算校验和              
 129   1      }
 130          /*写LM75中的功放保护和恢复门限*/
 131          void writeLM75(char point,char value,unsigned char num)
 132          {
 133   1              char temp[5];
 134   1              if(num==2)
 135   1              {
 136   2                      temp[0] = 0x01;
 137   2                      temp[1] = 0x18;                                                         //高字节在前
 138   2              }
 139   1              else if(num==3)
 140   1              {
 141   2                      temp[0] = point;
 142   2                      temp[1] = value;                                                                //高字节在前
 143   2                      temp[2] = 0x00;                                                                 //低字节在后
 144   2              }
 145   1              watchdog();
 146   1              ISendStrExt(0x90,temp,num);
 147   1      }
 148          /*开关射频*/
 149          void switchRF(unsigned char value)
 150          {
 151   1              if(value==0)
 152   1              {
 153   2                      RFswitch = 0;
 154   2              }
 155   1              else
 156   1              {
 157   2                      RFswitch = 1;
 158   2              }
 159   1      }
 160          /*开关功放*/
 161          void switchPA(unsigned char value)
 162          {
 163   1              if(value==0)
 164   1              {
 165   2                      PAswitch = 1;
 166   2              }
 167   1              else
 168   1              {
 169   2                      PAswitch = 0;
 170   2              }
 171   1      }
 172          /*写DA1661*/
 173          void writeDA1661(unsigned int value,unsigned char channel)
 174          {
 175   1              value <<=2;
 176   1              value &=0xFFFC;
 177   1              if(channel=='A')
 178   1              {
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 4   

 179   2                      value |= 0x9000;                                //高4位为模式控制位
 180   2              }
 181   1              else if(channel=='B')   
 182   1              {
 183   2                      value |= 0xA000;
 184   2              }
 185   1              LD = 1;
 186   1              LD = 0;
 187   1              CLK = 0;
 188   1              MSend_bit(value,16);
 189   1              LD = 1; 
 190   1      }
 191          /*写衰减器Att1--1U5(前部衰减器)*/
 192          void writeAtt1(unsigned char att1)
 193          {
 194   1              unsigned int value;
 195   1              LE1 = 0;
 196   1              value = (unsigned int)att1;
 197   1              value <<=10;
 198   1              MSend_bit(value,6);     
 199   1              LE1 = 1;
 200   1              LE1 = 0;
 201   1      }
 202          /*写衰减器Att2--2U6(后部衰减器)*/
 203          void writeAtt2(unsigned char att2)
 204          {
 205   1              unsigned int value;
 206   1              LE2 = 0;
 207   1              value = (unsigned int)att2;
 208   1              value <<=10;
 209   1              MSend_bit(value,6);     
 210   1              LE2 = 1;
 211   1              LE2 = 0;
 212   1      }
 213          /*设置总的衰减值*/
 214          unsigned char writeAttenuator(unsigned char bus, unsigned char attVal)
 215          {
 216   1              if(bus==0)
 217   1              {
 218   2                      if(attVal<=15)  
 219   2                      {
 220   3                              gAtt2 = gAtteVal<<1;                            //0.5dB步进需乘以2
 221   3                              gAtt2 += gGainOffset;                           //加上0.5dB步进的偏移值
 222   3                              gAtt2 += gAtttempval;                           //att2加上温度补偿值
 223   3                              writeAtt1(0);
 224   3                              writeE2prom(EE_Att1,0);                 
 225   3                      }
 226   2                      else 
 227   2                      {
 228   3                              gAtt2 = gGainOffset + 30;                       //15dB衰减值加上增益偏移
 229   3                              gAtt2 += gAtttempval;                           //att2加上温度补偿值
 230   3                              gAtt1 =gAtteVal-15;                                     //0.5dB步进需乘以2,即左移一位
 231   3                              gAtt1 <<= 1;
 232   3                              writeAtt1(gAtt1);       
 233   3                              writeE2prom(EE_Att1,gAtt1);                                     
 234   3                      }
 235   2              }
 236   1              else
 237   1              {
 238   2                      attVal <<= 1;
 239   2                      gAtt1 = attVal;
 240   2                      writeAtt1(gAtt1);       
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 5   

 241   2                      writeE2prom(EE_Att1,gAtt1);     
 242   2                      gAtt2 = gAtttempval + gGainOffset;      
 243   2              }
 244   1              if(gAtt2 > 0x3F)
 245   1              {
 246   2                      gAtt2 = 0x3F;
 247   2              }                               
 248   1              writeAtt2(gAtt2);
 249   1              writeE2prom(EE_Att2,gAtt2);     
 250   1                                              
 251   1              return TRUE;            
 252   1      }
 253          /*写锁相环*/
 254          void progPLL(unsigned char reg,unsigned long value)
 255          {       
 256   1              unsigned char num_bit,i;
 257   1              unsigned long masque_bit;
 258   1              unsigned char x;
 259   1      
 260   1              if(reg == 'C')
 261   1              {
 262   2                      num_bit = 20;
 263   2                      masque_bit = 0x80000L;  
 264   2              }
 265   1              else
 266   1              {
 267   2                      num_bit = 21;
 268   2                      masque_bit = 0x100000L; 
 269   2              }
 270   1              
 271   1              CLK = 0;                                        //初始状态
 272   1              LE3 = 1;
 273   1      
 274   1              LE3 = 0;
 275   1              for(i=0;i<num_bit;i++)
 276   1              {
 277   2                      if((value & masque_bit)==0)
 278   2                      {
 279   3                              DATA = 0;
 280   3                      }                       
 281   2                      else
 282   2                      {
 283   3                              DATA = 1;       
 284   3                      }
 285   2                      for(x=0;x<2;x++)
 286   2                      {
 287   3                      }
 288   2                      CLK = 1;
 289   2                      value <<= 1;
 290   2                      CLK = 0;
 291   2              }
 292   1              LE3 = 1;
 293   1      }
 294          /*
 295          **********************************************************************************************************
             -******
 296          *                         写锁相环
 297          *
 298          * Description: 根据设定的中心频率, 中频频率, 频率偏移, 频率步进, 频率温度补偿系数计算出各寄存器值, 再调用p
             -rogPLL
 299          *
 300          * Arguments  : 无
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 6   

 301          *
 302          * Returns    : 无
 303          **********************************************************************************************************
             -*******
 304          */
 305          void writePLL()
 306          {
 307   1              #define F_reg       0x000092L                                                                           //功能选择寄存器值固定为0x000092L                                       
 308   1      
 309   1              unsigned int value1,value2;
 310   1              int temperature;        
 311   1              bit flag_sa;
 312   1              unsigned char temp[4];
 313   1      
 314   1              readE2promStr(2,EE_IFOffset,temp);                                                                      //读取中频调整值,2个字节（即中频偏移值）
 315   1              swapBytes(temp, (unsigned char *)&gIFOffset,2);
 316   1      
 317   1              readE2promStr(4,EE_RefFreq,temp);                                                                       //读取参考频率，4个字节
 318   1              swapBytes(temp, (unsigned char *)&gRefFreq,4);
 319   1      
 320   1              if ( ( gIFOffset < -99 ) || ( gIFOffset > 99 ) ) 
 321   1              {               
 322   2                      gIFOffset = 0;
 323   2              }
 324   1              readE2promStr(2,EE_FreqStep,temp);                                                                      //读取中频步进值
 325   1              swapBytes(temp, (unsigned char *)&gFreqStep,2);
 326   1      
 327   1      
 328   1              if (gFreqStep == 0) 
 329   1              {
 330   2                      gFreqStep = 25;
 331   2              }
 332   1              readE2promStr(4,EE_CenFreq,temp);                                                                       //读取中心频率
 333   1              swapBytes(temp,(unsigned char *)&gCenFreq,4);
 334   1              
 335   1              readE2promStr(4,EE_IFFreq,temp);                                                                        //读取中频频率
 336   1              swapBytes(temp,(unsigned char *)&gIFFreq,4);
 337   1              
 338   1              gCenFreq -= gIFFreq;                                                                                            //中心频率减去中频频率值                
 339   1              gCenFreq /= gFreqStep; 
 340   1              gCenFreq += gIFOffset;
 341   1              
 342   1              if(gtestflag==1)
 343   1              {
 344   2                      return;
 345   2              }
 346   1              else
 347   1              {
 348   2                      readE2promStr(1,EE_SAWFNumer,&gSAWFNumer);                                              //读取声表温补分子
 349   2                      
 350   2                      value2 = (unsigned int)gSAWFNumer;
 351   2              
 352   2                      //readTemperatur();
 353   2                      temperature = gainCo;
 354   2                              
 355   2                      if (temperature < 0)
 356   2                      {
 357   3                              flag_sa = TRUE;
 358   3                              temperature = ~temperature + 1; 
 359   3                      }
 360   2                      else flag_sa = FALSE;
 361   2                      
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 7   

 362   2                      value1 = value2 * (unsigned int)temperature;
 363   2              
 364   2                      readE2promStr(1,EE_SAWFDenomi,&gSAWFDenomi);                                                                    //读取声表温补分母
 365   2                      if(gSAWFDenomi == 0)
 366   2                      {
 367   3                              gSAWFDenomi = 100;
 368   3                      }
 369   2                      value2 = (unsigned int)gSAWFDenomi;
 370   2              
 371   2                      value2 *= gFreqStep;
 372   2                      value1 /= value2;
 373   2      
 374   2                      value1 /= 2;
 375   2      
 376   2                      if (flag_sa)
 377   2                      {
 378   3                              gCenFreq -= (unsigned long)value1;
 379   3                      }
 380   2                      else
 381   2                      {
 382   3                              gCenFreq += (unsigned long)value1;
 383   3                      }
 384   2              }
 385   1              gCenFreq <<= 2;
 386   1              gCenFreq |= 0x100001L;
 387   1              progPLL( 'A', gCenFreq);                                //N-reg
 388   1      
 389   1              gCenFreq = gRefFreq;                                            //可变，可以是10M也可以是12M
 390   1              gCenFreq /= (unsigned long)gFreqStep;
 391   1              gCenFreq <<= 2;
 392   1              gCenFreq |= 0x100000L;
 393   1              progPLL( 'A', gCenFreq);                                //R-reg
 394   1              
 395   1              gCenFreq = F_reg;
 396   1              progPLL( 'C', gCenFreq);                                //F-reg
 397   1      
 398   1              
 399   1      }
 400          /*
 401          **********************************************************************************************************
             -******
 402          *                         温度补偿功放偏压值
 403          *
 404          * Description: 对功放偏压值进行重新设置 
 405          *
 406          * Arguments  : 无
 407          *
 408          * Returns    : 无
 409          **********************************************************************************************************
             -*******
 410          */
 411          void tempwritePAIq()
 412          {
 413   1              //int gainCo;
 414   1              unsigned int Iqnum;
 415   1      
 416   1          Iqnum =  gPAIqCo/10;
 417   1              gPAIqCoval = (int)Iqnum * gainCo;
 418   1              gPAIqCoval /= 10;
 419   1              gPAIqCoval /= 2;
 420   1              gPAIqact = gPAIq -  gPAIqCoval; 
 421   1              if(gPAIqact<0)
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 8   

 422   1              {
 423   2                      gPAIqact = 0;
 424   2              }                                 
 425   1              writeDA1661(gPAIqact,'B');              
 426   1      }
 427          /*
 428          **********************************************************************************************************
             -******
 429          *                         读取温度
 430          *
 431          * Description: 读取温度，定时执行，更新温度值 
 432          *
 433          * Arguments  : 无
 434          *
 435          * Returns    : 无
 436          **********************************************************************************************************
             -*******
 437          */
 438          void readTemperatur()
 439          {
 440   1              int value = 0;
 441   1      
 442   1              gpreRfTemp =  gcurRfTemp;
 443   1              
 444   1              IRcvStr(0x90,0x00,(unsigned char*)&value,2);    //读取温度，其中指针寄存器为00
 445   1              value >>= 7;
 446   1              gcurRfTemp = value;
 447   1      
 448   1              if(gtestflag==0)                                                                                        //不在调试状态下，使用实际温度
 449   1              {
 450   2                      gainCo = gcurRfTemp - 50;                                                               //0.5dB为步进故计算值要乘以2 
 451   2              }
 452   1              else if(gtestflag==2)
 453   1              {
 454   2                      gainCo = gtestRfTemp - 50;                                                              //0.5dB为步进故计算值要乘以2 
 455   2              }
 456   1      
 457   1      }
 458          /*
 459          **********************************************************************************************************
             -******
 460          *                         温度补偿
 461          *
 462          * Description: 根据读取的温度值，对衰减值和锁相环分别进行温补操作 
 463          *
 464          * Arguments  : 无
 465          *
 466          * Returns    : 无
 467          **********************************************************************************************************
             -*******
 468          */
 469          void tempCompensate() 
 470          {
 471   1              unsigned char numerator, denominator;
 472   1              int gainCotemp;
 473   1              unsigned char tmpAtt,bus;
 474   1      
 475   1              if( (softDownLoad == DOING)||(gtestflag==1) )
 476   1              {
 477   2                      return;
 478   2              }
 479   1              if( (rfPramModified == TRUE) || (gpreRfTemp != gcurRfTemp) )    //射频参数更改或温度有变化
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 9   

 480   1              {
 481   2                      readE2promStr(1,EE_GainNumer,&numerator);                                       //增益温补系数分子
 482   2                      readE2promStr(1,EE_GainDenomi,&denominator);                            //增益温补系数分母
 483   2                      readE2promStr(1,EE_TEMP_VALUE,&gTempgain);                              //读取温度基准值
 484   2                      if( gTempgain > 16 ) 
 485   2                      {               
 486   3                              gTempgain = 9;
 487   3                      }       
 488   2               
 489   2                      //gainCo = gainCo<<1;
 490   2                      gainCotemp = gainCo*numerator;
 491   2                      if(denominator == 0)
 492   2                      {
 493   3                              denominator = 100;
 494   3                      }
 495   2                      gainCotemp = gainCotemp/denominator;
 496   2                        
 497   2                      gainCotemp = gTempgain - gainCotemp;
 498   2                      if(gainCotemp < 0)
 499   2                      {
 500   3                              gAtttempval = 0;
 501   3                      }
 502   2                      else if(gainCotemp > 0x3F)
 503   2                      {
 504   3                              gAtttempval = 0x3F;
 505   3                      }
 506   2                      else
 507   2                      {
 508   3                              gAtttempval = (unsigned char)gainCotemp;
 509   3                      }
 510   2                      if((gRF_No&0xF0)==0)                                                    //取得通道号，上行or下行
 511   2                      {
 512   3                              bus = 0;
 513   3                      }
 514   2                      else
 515   2                      {
 516   3                              bus = 1;
 517   3                      }  
 518   2                      if(bus==0)
 519   2                      {
 520   3                              //上行，温补和增益调整、<＝15部分放在Att2－2U6；>15部分放在Att1－1U5                                                                            
 521   3                              if(gAtteVal<=15)                                                                                                   
 522   3                              {
 523   4                                      tmpAtt = gAtteVal<<1;                   //0.5dB步进需乘以2
 524   4                                      tmpAtt += gAtttempval;
 525   4                                      tmpAtt += gGainOffset;
 526   4                              }
 527   3                              else
 528   3                              {
 529   4                                      tmpAtt = gAtttempval + 30;                      //0.5dB步进需乘以2
 530   4                                      tmpAtt += gGainOffset;  
 531   4                              }
 532   3                      }
 533   2                      else
 534   2                      {
 535   3                              //下行，温补和增益调整放在Att2－2U6，增益设定值全部放在Att1－1U5
 536   3                              tmpAtt =  gAtttempval + gGainOffset ;
 537   3                      }
 538   2                      if(tmpAtt > 0x3F)
 539   2                      {
 540   3                              tmpAtt = 0x3F;
 541   3                      }                               
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 10  

 542   2                      writeAtt2(tmpAtt);
 543   2                      gAtt2 = tmpAtt; 
 544   2                      watchdog();
 545   2                      writePLL();     
 546   2                      watchdog();
 547   2                      tempwritePAIq();                                                        //对功放偏压进行温度补偿
 548   2              }   
 549   1              rfPramModified = FALSE;                                                 //射频参数修改标志      
 550   1      
 551   1      }
 552          /*
 553          *********************************************************************************************************
 554          *                         A/D转换
 555          *
 556          * Description: 根据给定的A/D转换通道，取得相应的A/D转换值
 557          *
 558          * Arguments  : channel  给定的通道号
 559          *
 560          * Returns    : value    转换结果
 561          *********************************************************************************************************
 562          */
 563          unsigned int readAD(unsigned char channel)
 564          {
 565   1              unsigned int value = 0; 
 566   1              unsigned int temp = 0;
 567   1              
 568   1              AD0INS  = channel;                                              //选择转换通道
 569   1              AD0MODA|= 0x10;                                                 //单次转换
 570   1              
 571   1              AD0CON = 0x05;                                                  //立即启动
 572   1              while(!AD0CON&0x08);                                    //等待转换完毕
 573   1      
 574   1              if(channel==1)
 575   1              {
 576   2                      value |= AD0DAT0R;                                      //右边字节，低位
 577   2                      temp  |= AD0DAT0L;                                      //左边字节，高位
 578   2              }
 579   1              else if(channel==2)
 580   1              {
 581   2                      value |= AD0DAT1R;
 582   2                      temp  |= AD0DAT1L;
 583   2              }
 584   1              else if(channel==8)
 585   1              {
 586   2                      value |= AD0DAT3R;
 587   2                      temp  |= AD0DAT3L;
 588   2              }
 589   1              else if (channel==16)
 590   1              {                                       
 591   2                      value |= AD0DAT4R;
 592   2                      temp  |= AD0DAT4L;
 593   2      
 594   2              }
 595   1          temp <<= 2;
 596   1              temp &= 0x0300;
 597   1              value &= 0x00FF;
 598   1              temp |= value;
 599   1              return temp;
 600   1      
 601   1      }
 602          /*
 603          *********************************************************************************************************
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 11  

 604          *                         计算程序校验和
 605          *
 606          * Description: 读取flash中的代码，计算校验和
 607          *
 608          * Arguments  : 无
 609          *
 610          * Returns    : 计算结果保存在全局变量all_checksum中
 611          *********************************************************************************************************
 612          */
 613          void execCheckSumQ()
 614          {
 615   1              unsigned char code *data pt_flash;      
 616   1              all_checksum = 0;
 617   1              for (pt_flash = 0x0000; pt_flash < 0x1D00; pt_flash++)
 618   1              {
 619   2                      all_checksum += *pt_flash;
 620   2                      watchdog();
 621   2              }
 622   1              for (pt_flash = 0x0000; pt_flash < 0xE300; pt_flash++)
 623   1              {
 624   2                      all_checksum += 0xFF;
 625   2                      watchdog();
 626   2              }
 627   1      }
 628          /*
 629          *********************************************************************************************************
 630          *                         上电复位主动发起命令
 631          *
 632          * Description: 主动发送一个下载确认命令，复位时发送
 633          *
 634          * Arguments  : 无
 635          *
 636          * Returns    : 无
 637          *********************************************************************************************************
 638          */
 639          void sendInitpacket()
 640          {       
 641   1              RxBuf[0] = 0x00;        //主控板地址
 642   1              RxBuf[1] = 8;           //长度
 643   1              RxBuf[2] = 0xA0;        //命令标识
 644   1              RxBuf[3] = 0x00;        //应答标志
 645   1              RxBuf[4] = 6;           //监控对象长度
 646   1              RxBuf[5] = 0xFD;
 647   1              RxBuf[6] = 0x0A;
 648   1              RxBuf[7] = 0x01;
 649   1              RxBuf[8] = 0x01;
 650   1              RxBuf[9] = 0x01;
 651   1      
 652   1              Data_len = 10;
 653   1      
 654   1              sendPkt();
 655   1      }
 656          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2405    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      45
   IDATA SIZE       =   ----    ----
C51 COMPILER V7.06   RFCONTROL                                                             03/30/2006 11:34:47 PAGE 12  

   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
