C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE BRO20W_PACKET
OBJECT MODULE PLACED IN .\OUTPUT\bro20W_packet.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE APP\bro20W_packet.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\my_proj
                    -ect.ORC) BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\bro20W_packet.lst) TABS(2) OBJECT(.\OUTPU
                    -T\bro20W_packet.obj)

line level    source

   1          
   2          /**-------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
   3          **ÎÄ   ¼þ   Ãû: packet.c
   4          **´´   ½¨   ÈË: ³ÌÝººì 
   5          **°æ        ±¾: V1.0
   6          **ÈÕ¡¡      ÆÚ: 2006Äê9ÔÂ30ÈÕ
   7          **×î ÐÂ °æ  ±¾: V1.6
   8          **Ãè        Êö:     ¶Ô°üµÄ½âÊÍ£¬²¢´¦Àí,²¢²Ù×÷ÉäÆµ¿ª¹Ø£¬PLLµÈ
   9          **
  10          ********************************************************************************************************/
  11          
  12          #include <reg938.h>
  13          #include <stdio.h>
  14          #include <string.h>   
  15          #include <I2C.h>
  16          #include <SPI.h>
  17          #include <cpu.h>
  18          #include <serial.h>
  19          #include <task.h>
  20          #include <packet.h>
  21          #include <bro20W_RFparam.h>
  22          #include <bro20W_RFcontrol.h>
  23          #include <e2prom.h>
  24          #include <readad.h>
  25          #include <timer.h>
  26          //#include "flash_config.h"
  27          //#include "compiler.h"
  28          //#include "flash_api.h"
  29          
  30          /*Èí¼þÏÂÔØ*/
  31          static unsigned int xdata nextSoftPktSn;        //ÇëÇóÈí¼þÏÂÔØ°üµÄÐòºÅ
  32          static unsigned int xdata preSoftChecksum = 0xFFFF;   //Ç°´ÎÏÂÔØÈí¼þµÄÐ£ÑéºÍ
  33          static unsigned int xdata softChecksum;         //Õû¸öÈí¼þµÄchecksumÖµ
  34          static unsigned int xdata softLen = 0;          //Èí¼þ×Ü³¤¶È
  35          //static unsigned char idata pktDataBuf[32];
  36          unsigned char code factry[8]={0xF0,0xD8,0x80,0xA8,0x5F,0xE0,0x87,0xC9}; 
  37          #if debug == 1
                unsigned char code debugstr[17]={0x01,0x0F,0xA0 ,0xFF ,0x0D ,0xDA ,0x0A ,0x01 ,0x00 ,0x00 ,0x40 ,0x00 ,0x
             -04 ,0xE8 ,0xAF ,0x0D ,0x00};
              #endif 
  40          
  41          /*
  42          *********************************************************************************************************
  43          *                         Êý¾Ý°ü½âÂë            
  44          *
  45          * Description: ¶ÔreadXPktBufÖÐµÄÊý¾Ý½øÐÐ½âÂë£¬°üÀ¨¶þ×Ö²ð·Ö£¬Çø·ÖÃüÁîºÍÊý¾Ý£¬È¡µÃCRCÖµ
  46          *
  47          * Arguments  : ÎÞ
  48          *
  49          * Returns    : ÎÞ
  50          *********************************************************************************************************
  51          */
  52          void execute_cmd() 
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 2   

  53          {
  54   1        unsigned char resultCode = NO_ERR;    
  55   1        unsigned char downresult = NO_ERR;
  56   1        switch(RxBuf[5])
  57   1        {
  58   2          case 0xDA:                    //²éÑ¯ºÍÉèÖÃ¹¤³§²ÎÊý
  59   2          {
  60   3            execFctParamSet();  
  61   3            break;
  62   3            }
  63   2          case 0xF0:                    //RFÄ£ ¿éÉäÆµ£¨¹¤³§£©²ÎÊý²éÑ¯   
  64   2          {
  65   3            execRFParamQ();
  66   3            break;
  67   3          }
  68   2          case 0xFD:                    //Èí¼þÏÂÔØÈ·ÈÏ»ò²éÑ¯Ä£¿éÐÅÏ¢  
  69   2          {
  70   3            if(RxBuf[7]==0x01)
  71   3            {
  72   4              if(RxBuf[8]==0)             //ÏÂÔØÈ¡Ïû
  73   4              {
  74   5                Data_len = 10;
  75   5                softDownLoad = UNDO;
  76   5              }
  77   4              else                  //ÏÂÔØÈ·ÈÏ
  78   4              {
  79   5                if(softDownLoad == DOING)
  80   5                {
  81   6                  downresult = endDwnldSoft();
  82   6                  RxBuf[6] |= downresult;       //´íÎó´úÂë±êÖ¾
  83   6                }
  84   5                else
  85   5                {
  86   6                  RxBuf[6] |= OTHER_ERR;        //´íÎó´úÂë±êÖ¾
  87   6                }
  88   5                Data_len = 10;
  89   5              }
  90   4            }
  91   3            break;
  92   3          }
  93   2          case 0xFE:                    //Èí¼þÏÂÔØ      
  94   2          {
  95   3              DwnldSoft1m_time = getTime();
  96   3            resultCode = execDwnldSoft();
  97   3            RxBuf[1] = 9;               //Êý¾Ý°ü³¤¶È   
  98   3            RxBuf[4] = 7;
  99   3            RxBuf[6] |= resultCode;           //´íÎó´úÂë±êÖ¾
 100   3            RxBuf[9] = (unsigned char)nextSoftPktSn;
 101   3            RxBuf[10] = (unsigned char)(nextSoftPktSn>>8);
 102   3            Data_len = 11;
 103   3            break;
 104   3          }
 105   2          case 0xFB:
 106   2          {
 107   3            if(RxBuf[7] == 0x01)
 108   3            {
 109   4              AUXR1 = 8;                                //Èí¼þ¸´Î»   20080618
 110   4            }
 111   3            break;
 112   3          }
 113   2        
 114   2          default:                    //ÃüÁî±àºÅ´í
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 3   

 115   2          {
 116   3            RxBuf[6] |= OCID_ERR;           //¼à¿Ø¶ÔÏó±êºÅÎÞ·¨Ê¶±ð  
 117   3            break;
 118   3          }
 119   2        } 
 120   1      }
 121          
 122          /*
 123          *********************************************************************************************************
 124          *                         Êä³ö¹¦ÂÊ²ÉÑù            
 125          *
 126          * Description: 
 127          *
 128          * Arguments  : ÎÞ
 129          *
 130          * Returns    : ÎÞ
 131          *********************************************************************************************************
 132          */
 133          void OutputPwrsampling()
 134          {
 135   1        unsigned char temp[4];
 136   1        unsigned char gPReadADNumerN;
 137   1        unsigned char i;
 138   1        int calVal;
 139   1      
 140   1        OutputPwr = 0;
 141   1      
 142   1        for(i=0;i<8;i++)
 143   1        {
 144   2          //OutputPwr += readAD(CHANNEL_0);
 145   2          OutputPwr += readAD(CHANNEL_4);
 146   2        }
 147   1        
 148   1        OutputPwr >>= 3;
 149   1      
 150   1        readE2promStr(1,EE_gPReadADNumer,temp);     //¶ÁÈ¡ ¹¦ÂÊ¶ÁÈ¡²¹³¥·Ö×Ó         
 151   1        swapBytes(temp,(unsigned char *)&gPReadADNumer,1);
 152   1      
 153   1        readE2promStr(1,EE_gPequDenomi,temp);     //¶ÁÈ¡ ¹¦ÂÊ²¹³¥·ÖÄ¸         
 154   1        swapBytes(temp,(unsigned char *)&gPequDenomi,1);
 155   1      
 156   1        //readE2promStr(4,EE_CenFreq,temp);       //¶ÁÈ¡ ÖÐÐÄÆµÂÊ
 157   1        //swapBytes(temp,(unsigned char *)&gCenFreq,4);
 158   1      
 159   1          readE2promStr(4,EE_gPBmFreq,temp);        //¶ÁÈ¡ »ù×¼ÆµÂÊ
 160   1        swapBytes(temp,(unsigned char *)&gPBmFreq,4);
 161   1      
 162   1        gPReadADNumerN = ~gPReadADNumer + 1;
 163   1      
 164   1        calVal = OutputPwr;
 165   1        if(gCenFreq < gPBmFreq)
 166   1        {
 167   2          if(gPReadADNumer < 0)
 168   2          {
 169   3            calVal += (gPBmFreq - gCenFreq) * gPReadADNumerN / (gPequDenomi * 1000);
 170   3          }
 171   2          else
 172   2          {
 173   3            calVal -= (gPBmFreq - gCenFreq) * gPReadADNumer / (gPequDenomi * 1000);
 174   3          }
 175   2        }                 
 176   1        else if(gPBmFreq < gCenFreq)
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 4   

 177   1        {
 178   2          if(gPReadADNumer < 0)
 179   2          {
 180   3            calVal -= (gCenFreq - gPBmFreq) * gPReadADNumerN / (gPequDenomi * 1000);
 181   3          }
 182   2          else
 183   2          {
 184   3            calVal += (gCenFreq - gPBmFreq) * gPReadADNumer / (gPequDenomi * 1000);
 185   3          }
 186   2        }
 187   1      
 188   1        //ÅÐ¶Ï·¶Î§£¬·ÀÖ¹Òç³ö
 189   1        if(calVal < 0)
 190   1        {
 191   2          OutputPwr = 0;
 192   2        }
 193   1        else if(calVal > 1023)
 194   1        {
 195   2          OutputPwr = 1023;
 196   2        }
 197   1        else
 198   1        {
 199   2          OutputPwr = calVal;
 200   2        }
 201   1      
 202   1      }
 203          /*
 204          *********************************************************************************************************
 205          *                         ¶¨Ê±²éÑ¯¸æ¾¯ÐÅÏ¢            
 206          *
 207          * Description: 
 208          *
 209          * Arguments  : ÎÞ
 210          *
 211          * Returns    : ÎÞ
 212          *********************************************************************************************************
 213          */
 214          void updateAlmInfo() small
 215          {
 216   1        unsigned char i;
 217   1        static unsigned char preRFSW;
 218   1      //  static unsigned char gRFSWtemp = 0;
 219   1      //  unsigned char tempNum;
 220   1      
 221   1        //preRFSW = gRFSW;                        //·ÅÔÚ²Ù×÷ÉäÆµ¿ª¹ØÖ®ºó
 222   1      
 223   1        PA_current = 0;
 224   1        re_Pwr =0;
 225   1        OutputPwr = 0;  
 226   1      
 227   1        if(gRFSW == CLOSE)
 228   1        {
 229   2          Lim_state = 0;                //ÉäÆµ¿ª¹Ø¹Ø±ÕÊ±ÏÞ·ù×´Ì¬ÎªÕý³£
 230   2        }
 231   1        else
 232   1        { 
 233   2          Lim_state = (LimYes == 0 ? FALSE : TRUE );  //¼ì²âÏÞ·ù×´Ì¬
 234   2        }
 235   1          
 236   1        PLL_state = (LockYes == 1 ? FALSE : TRUE);    //¼ì²âÊ§Ëø×´Ì¬
 237   1         
 238   1        watchdog();
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 5   

 239   1            
 240   1        if(AutoSwitch == CLOSE)               //ÆµÂÊÃ»Ëø¶¨»òÕßÊÖ¶¯Ç¿ÖÆ¹Ø±ÕÔò¹Ø±Õ¹¦·Å
 241   1        {
 242   2          gRFSW = CLOSE;
 243   2          TempOverAlm = 0;
 244   2        }
 245   1        else
 246   1        {
 247   2          if(gcurRfTemp > 2*gPAProtecttLim)
 248   2          {
 249   3            gRFSW = CLOSE;
 250   3            TempOverAlm = 1;
 251   3          }
 252   2          else 
 253   2          if(gcurRfTemp < 2*gPAResetLim)
 254   2          {
 255   3            gRFSW = OPEN;
 256   3            TempOverAlm = 0;             
 257   3          }
 258   2        }
 259   1        
 260   1        switchRF(gRFSW);
 261   1          
 262   1        if(preRFSW != gRFSW)                //¿ª¹Ø±ä»¯ÔòÖØÐ´ËøÏà»·
 263   1        {
 264   2          writePLL();
 265   2            if(gRFSW==OPEN)
 266   2           {
 267   3             delay(2);   
 268   3           }
 269   2        }
 270   1        preRFSW = gRFSW;
 271   1      
 272   1        /*for(i=0;i<20;i++)                              //ÏÈ¶Á100´Î²¢ÇÒ¶ªÆú£¬¼Ó¿ì²ÉÑùËÙ¶È
 273   1        {
 274   1          readAD(CHANNEL_0);
 275   1          readAD(CHANNEL_1);              //¶Á·´Éä¹¦ÂÊADÖµ
 276   1          readAD(CHANNEL_5);
 277   1        } */
 278   1      
 279   1        for(i=0;i<8;i++)
 280   1        {
 281   2      //    re_Pwr += readAD(CHANNEL_1);        //¶Á·´Éä¹¦ÂÊADÖµ
 282   2      //    PA_current += readAD(CHANNEL_5);      //¶Á³ö¹¦·ÅµçÁ÷ADÖµ
 283   2          re_Pwr += readAD(CHANNEL_5);        //¶Á·´Éä¹¦ÂÊADÖµ
 284   2          PA_current += readAD(CHANNEL_1);      //¶Á³ö¹¦·ÅµçÁ÷ADÖµ
 285   2        }
 286   1      
 287   1        re_Pwr >>= 3;
 288   1        PA_current >>= 3;
 289   1        OutputPwrsampling();              //ÕýÏò¹¦ÂÊµÄ¶ÁÈ¡
 290   1        AD0CON = 0x01;              //¹Ø±Õ×ª»»£¬ÒÔ·ÀÖ¹³öÏÖ¹Ü½ÅÏà»¥Ó°ÏìÏÖÏó¡£add by dw   20090623
 291   1          
 292   1      #if debug == 1
                memcpy(RxBuf,debugstr,17);
                pack_valid = 1;
              #endif
 296   1      
 297   1        watchdog();           
 298   1      }
 299          /*
 300          *********************************************************************************************************
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 6   

 301          *                         ¹¤³§²ÎÊýÉèÖÃÃüÁî            
 302          *
 303          * Description: ±êºÅ·ÖÅäÎª0x0ADA£¬¶Ô¸÷¸ö¹¤³§²ÎÊý½øÐÐÉèÖÃ£¬²éÑ¯ÔÚÁíÒ»ÃüÁîÖÐ
 304          *
 305          * Arguments  : ÎÞ
 306          *
 307          * Returns    : ÎÞ
 308          *********************************************************************************************************
 309          */
 310          void execFctParamSet()
 311          {
 312   1      
 313   1        unsigned char tempLen;//,bufPoint;
 314   1        unsigned short param_addr;//,j;//,j;                      //²ÎÊý¶ÔÓ¦µÄEEPROMµØÖ·
 315   1        unsigned short tmpInt=0;//j;
 316   1      //  unsigned long tmpLong=0;
 317   1        unsigned char temp[4];
 318   1        unsigned short tPALim;
 319   1        
 320   1        param_addr = RxBuf[10];
 321   1        param_addr += (RxBuf[11]<<8);                  //²ÎÊý¶ÔÓ¦µÄEEPROMµØÖ·
 322   1      
 323   1        tempLen = RxBuf[12];
 324   1        
 325   1        tPALim = gPALim;
 326   1      
 327   1        if(RxBuf[7]==0)                   //¹¤³§²ÎÊý²éÑ¯
 328   1        { 
 329   2          readE2promStr(tempLen,param_addr,&RxBuf[13]);            //Ò»°ã²ÎÊýÔÚE2PROMÖÐ¶ÁÈ¡
 330   2              
 331   2          switch(param_addr)                                          //¸ö±ð²ÎÊýÔòÐèÒªÊµÊ±²éÑ¯
 332   2          {
 333   3            case 0x0040:
 334   3              if ( RFSrcSelect )
 335   3              {
 336   4                RxBuf[13] = 0,RxBuf[14] = 0,RxBuf[15] = 0,RxBuf[16] = 0;
 337   4              }
 338   3              break;
 339   3            case EE_DA_CHANNEL_B:               
 340   3              RxBuf[13] = gDAoutB*gRFSW;
 341   3              RxBuf[14] = (gDAoutB*gRFSW)>>8;
 342   3              break;
 343   3            case EE_DA_CHANNEL_C:
 344   3              RxBuf[13] = gDAoutC*gRFSW;
 345   3              RxBuf[14] = (gDAoutC*gRFSW)>>8;
 346   3              break;
 347   3            case 0x00A4:
 348   3              IRcvStr(0x90,0x03,temp,2);         //0x90 ÓÉ1 £¬0 £¬0 £¬1 ,  A2  £¬A1£¬ A0£¬R/W ×é³É£¬¸ßËÄÎ»¹Ì¶¨£¬µÍËÄ
             -Î»ÊÇµØÖ·Î»¡¢¶ÁÐ´Î»
 349   3              RxBuf[13] = temp[0];                  //0x03±íÊ¾Òª¶ÁÈ¡µÄIICÆ÷¼þÄÚ²¿¼Ä´æÆ÷µØÖ·
 350   3              break;
 351   3            case 0x00A5:
 352   3              IRcvStr(0x90,0x02,temp,2);
 353   3              RxBuf[13] = temp[0];
 354   3              break;        
 355   3      
 356   3            case 0x00C1:
 357   3            case 0x00C2:                      
 358   3              RxBuf[13] = gRFSW;
 359   3              break;
 360   3      /*        case 0x00C4:
 361   3              RxBuf[13] = PLL_state;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 7   

 362   3              break;
 363   3      
 364   3            case 0x00C5:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
 365   3              RxBuf[13] = Lim_state;
 366   3              break;
 367   3            case 0x00C6:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 368   3              RxBuf[13] = (unsigned char)PA_current;
 369   3              RxBuf[14] = (unsigned char)(PA_current >> 8);
 370   3              break;
 371   3            case 0x00C7:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
 372   3              RxBuf[13] = (unsigned char)OutputPwr;
 373   3              RxBuf[14] = (unsigned char)(OutputPwr >> 8);
 374   3              break;
 375   3            case 0x00C8:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 376   3              RxBuf[13] = (unsigned char)re_Pwr;
 377   3              RxBuf[14] = (unsigned char)(re_Pwr >> 8);
 378   3              break;*/
 379   3            case 0x00CA:  
 380   3                          
 381   3              RxBuf[13] = (unsigned char)gcurRfTemp;
 382   3              RxBuf[14] = (unsigned char)(gcurRfTemp >> 8);
 383   3              break;
 384   3      
 385   3            case 0x00E0:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 386   3              RxBuf[13] = Ver_Low;
 387   3              RxBuf[14] = Ver_High;
 388   3              break;
 389   3            case 0x00E2:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
 390   3              RxBuf[13] = (unsigned char)all_checksum;
 391   3              RxBuf[14] = (unsigned char)(all_checksum >> 8);
 392   3              break;
 393   3              default:
 394   3                break;            
 395   3          }
 396   2        }
 397   1        else                                                    //¹¤³§²ÎÊýÉè¶¨
 398   1        {
 399   2          
 400   2          if (tempLen==2)
 401   2          {
 402   3            tmpInt = RxBuf[13];
 403   3            tmpInt += (RxBuf[14]<<8);   
 404   3          }
 405   2        
 406   2          //switch(param_addr):Ö÷ÒªÓÃÓÚ¶Ô½ÓÊÕµÄÊý¾Ý½øÐÐ¼ìÑé£¬ÊÇ·ñÎªÕý³£ÖµµÄ·¶Î§ÄÚ£¬Èô²»ÊÇ£¬Ôò²»´æÈëEEPROM
 407   2          switch(param_addr)
 408   2          {
 409   3            //2×Ö½Ú£¬¹¦·ÅÏÞ·ù
 410   3            case EE_DA_CHANNEL_B:
 411   3            case EE_DA_CHANNEL_C:
 412   3              if ( tmpInt > 1023 )
 413   3                RxBuf[6] |= DATRANGE_ERR; 
 414   3              break;
 415   3            case 0x0020:                  //2×Ö½Ú,¹¦·ÅÆ«Ñ¹Öµ      
 416   3              if( (tmpInt<0)||(tmpInt>1023) )
 417   3              {
 418   4                RxBuf[6] |= DATRANGE_ERR; 
 419   4              }
 420   3              break;                  //1×Ö½Ú£¬ÔöÒæÎÂ²¹ÏµÊý·Ö×Ó
 421   3            case 0x00A2:                  //1×Ö½Ú£¬ÔöÒæÎÂ²¹ÏµÊý·ÖÄ¸
 422   3            case 0x00A3:
 423   3              if((RxBuf[13]<0)||(RxBuf[13]>255))
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 8   

 424   3              {
 425   4                RxBuf[6] |= DATRANGE_ERR; 
 426   4              }
 427   3              break;
 428   3            case 0x00A5:                  //1×Ö½Ú£¬¹¦·ÅÖØÆðÎÂ¶ÈÏÂÏÞ   
 429   3              if((RxBuf[13]<0)||(RxBuf[13]>125))
 430   3              {
 431   4                RxBuf[6] |= DATRANGE_ERR; 
 432   4              }
 433   3              break;
 434   3            case 0x00D2:                  //1×Ö½Ú£¬µ÷ÊÔ×´Ì¬  
 435   3              if((RxBuf[13]<0)||(RxBuf[13]>2))      
 436   3              {
 437   4                RxBuf[6] |= DATRANGE_ERR; 
 438   4              }
 439   3              break;    
 440   3            case 0x00D3:                  //1×Ö½Ú£¬ÎÂ²¹»ù×¼Öµ  
 441   3              if((RxBuf[13]<0)||(RxBuf[13]>200))
 442   3              {
 443   4                RxBuf[6] |= DATRANGE_ERR; 
 444   4              }
 445   3              break;
 446   3            default:
 447   3              break;    
 448   3          }
 449   2          if(RxBuf[6]==0x0A)                  //½ÓÊÕµÄÊý¾ÝÎªÕý³£Öµ£¬Ôò¿ªÊ¼½«Êý¾Ý´æEEPROM
 450   2          {
 451   3            if(param_addr != 0x0140)
 452   3            {
 453   4              if ( param_addr == 0x0040 && tempLen == 6 )                     //2012-6-19 HANÔö
 454   4              {
 455   5                writeE2promStr(4,0x0040,&RxBuf[13]);
 456   5                writeE2promStr(2,0x0020,&RxBuf[17]);                
 457   5              }
 458   4              else                                                            //han,³¤¡¢ÃüÁîÊÇ40£¬³¤¶ÈÊÇ6£¬×öÉÏÊöÊÂ¡
             -£
 459   4              {
 460   5                writeE2promStr(tempLen,param_addr,&RxBuf[13]);      
 461   5              }
 462   4            }
 463   3            rfPramModified = TRUE;              //ÉäÆµ²ÎÊýÐÞ¸Ä±êÖ¾ÓÐÐ§  
 464   3            switch(param_addr)
 465   3            {
 466   4              case EE_TEMPER_BUCHANG:
 467   4                memcpy(__temp_que,RxBuf+13,sizeof(__temp_que));
 468   4              break;
 469   4              case EE_PLUS_TRIGER://´¥·¢µ¥´ÎÂö³åÐÅºÅ
 470   4                EA = 0;
 471   4                __PlusSwitchState = OPEN;
 472   4                __PlusReqAddr     = RxBuf[13];
 473   4                __PlusReqPower    = RxBuf[14];
 474   4                __PlusReqFreq     = RxBuf[15]+(RxBuf[16]<<8);
 475   4                EA = 1;
 476   4              break;
 477   4              case EE_DA_CHANNEL_B:
 478   4                gDAoutB = tmpInt;         
 479   4                writeAD5314(gDAoutB,'B');
 480   4              break;
 481   4              case EE_DA_CHANNEL_C:
 482   4                gDAoutC = tmpInt;
 483   4                writeAD5314(gDAoutC,'C');         
 484   4              break;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 9   

 485   4              case EE_SOURCE_SELECT:
 486   4                RFSrcSelect = (RxBuf[13] != SRC_INTERNAL && RxBuf[13] != SRC_EXTERNAL)?SRC_INTERNAL:RxBuf[13];          
 487   4                writePLL();
 488   4              break;
 489   4              //--------------------------ÔöÒæ-------------------------------
 490   4                //---------ÉÏÐÐÔöÒæ------------
 491   4              case 0x0003:
 492   4                 gGain=RxBuf[13];
 493   4                 writeAtt1(gGain);
 494   4                 updateAlmInfo();
 495   4              case 0x0020:                  //2×Ö½Ú£¬Êä³ö¹¦ÂÊÏÞ·ùÖµ                 
 496   4                //2012.10.26
 497   4                gPALimCompensate();
 498   4                gPALim = (gPALim + tPALim)/2;         
 499   4                writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 500   4                updateAlmInfo();          
 501   4                
 502   4                delay(1);
 503   4                
 504   4                gPALimCompensate();
 505   4                writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 506   4                updateAlmInfo();
 507   4                //Task5S_time = getTime() + 100;
 508   4                break;        
 509   4              case 0x0040:                //4×Ö½Ú£¬ÖÐÐÄÆµÂÊ
 510   4              case 0x0140:
 511   4                //gCenFreq = tmpLong;
 512   4                swapBytes(&RxBuf[13],(unsigned char *)&gCenFreq,4);
 513   4                writePLL();
 514   4                delay(1);
 515   4                //gPALimCompensate();
 516   4                            //writeAD5314(gPALim,'B');         //¸Ä±äÖÐÐÄÆµÂÊÐèÒªÍ¬Ê±½øÐÐÏÞ·ù²¹³¥
 517   4      
 518   4                  /*2012.6.19 HAN add*/
 519   4                //2012.10.26
 520   4                if ( tempLen == 6 )
 521   4                {
 522   5                  gPALimCompensate();
 523   5                  gPALim = (gPALim + tPALim)/2;         
 524   5                  writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 525   5                  updateAlmInfo();          
 526   5                  
 527   5                  delay(1);
 528   5                  
 529   5                  gPALimCompensate();
 530   5                  writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 531   5                  updateAlmInfo();            
 532   5                }  
 533   4      
 534   4                break;
 535   4      
 536   4              case 0x004A:                //2×Ö½Ú£¬ÆµÂÊ²½½øÖµ
 537   4              case 0x0054:                //4×Ö½Ú£¬²Î¿¼ÆµÂÊ
 538   4                writePLL();
 539   4                break;
 540   4      
 541   4              case 0x0075:                      //¹¦ÂÊÏÞ·ù²¹³¥·Ö×Ó
 542   4      //          case 0x0076:
 543   4              case 0x0077:                      //¹¦ÂÊ²¹³¥·ÖÄ¸
 544   4              case 0x0078:                     //»ù×¼ÆµÂÊ
 545   4                //2012.10.26
 546   4                gPALimCompensate();
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 10  

 547   4                gPALim = (gPALim + tPALim)/2;         
 548   4                writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 549   4                updateAlmInfo();          
 550   4                
 551   4                delay(1);
 552   4                
 553   4                gPALimCompensate();
 554   4                writeAD5314(gPALim,DAPOWER_LIM_CHAN);
 555   4                updateAlmInfo();          
 556   4                break;
 557   4      
 558   4              case 0x00A4:                  //2×Ö½Ú£¬¹¦·Å±£»¤ÎÂ¶ÈÏÂÏÞ
 559   4                gPAProtecttLim = RxBuf[13];
 560   4                writeLM75(0x03,gPAProtecttLim,3); 
 561   4                break;
 562   4      
 563   4              case 0x00A5:                  //2×Ö½Ú£¬¹¦·ÅÖØÆðÎÂ¶ÈÏÂÏÞ
 564   4                gPAResetLim = RxBuf[13];
 565   4                writeLM75(0x02,gPAResetLim,3);  
 566   4                break;
 567   4      
 568   4              case 0x00C0:                  //1×Ö½Ú£¬ÉäÆµÄ£¿é±àºÅ
 569   4                gRF_No = RxBuf[13]; 
 570   4                break;
 571   4      
 572   4              case 0x00C2:                  //1×Ö½Ú£¬ÉäÆµ¿ª¹Ø
 573   4                if(AutoSwitch != RxBuf[13]);
 574   4                {
 575   5                  AutoSwitch = RxBuf[13];
 576   5      
 577   5                  updateAlmInfo();
 578   5                  writeAtt1(gGain);
 579   5                  writePLL();                      //ÉäÆµ¿ª¹Ø¶¯×÷ÁË£¬Ã¿´ÎÒª´ÓÐÂ²Ù×÷ËøÏà                       ·
 580   5      /*            if(AutoSwitch == CLOSE)
 581   5                  {
 582   5                      gRFSW = CLOSE;
 583   5                    switchRF(gRFSW);
 584   5                  }
 585   5                  else if(gcurRfTemp < 2*gPAProtecttLim)
 586   5                  {*/
 587   5                      //gRFSW = OPEN;
 588   5                    //switchRF(gRFSW);
 589   5                    //Task5S_time = getTime();
 590   5      //            }
 591   5                }
 592   4                watchdog();     
 593   4                break;  
 594   4              default:
 595   4                break;                
 596   4            }
 597   3          }
 598   2        }
 599   1        Data_len = RxBuf[1] + 2;
 600   1      }
 601          
 602          void sendInitpacket()
 603          {
 604   1        readE2promStr(1,EE_DOWN_FLAG,&gDownFlag);
 605   1      
 606   1        if(gDownFlag == 0xFF)
 607   1        { 
 608   2          gDownFlag = 0x00;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 11  

 609   2          writeE2promStr(1,EE_DOWN_FLAG,&gDownFlag);     
 610   2      
 611   2          RxBuf[0] = 0x00;  //Ö÷¿Ø°åµØÖ·
 612   2          RxBuf[1] = 8;     //³¤¶È
 613   2          RxBuf[2] = 0xA0;  //ÃüÁî±êÊ¶
 614   2          RxBuf[3] = 0x00;  //Ó¦´ð±êÖ¾
 615   2          RxBuf[4] = 6;   //¼à¿Ø¶ÔÏó³¤¶È
 616   2          RxBuf[5] = 0xFD;
 617   2          RxBuf[6] = 0x0A;
 618   2          RxBuf[7] = 0x01;
 619   2          RxBuf[8] = 0x01;
 620   2          RxBuf[9] = 0x01;
 621   2      
 622   2          Data_len = 10;
 623   2      
 624   2          sendPkt();
 625   2        }
 626   1      }
 627          
 628          /*
 629          *********************************************************************************************************
 630          *                         RFÄ£¿éÉäÆµ²ÎÊý²éÑ¯            
 631          *
 632          * Description: ±êºÅ·ÖÅäÎª0x0AF0£¬¶Ô¸÷¸ö¹¤³§²ÎÊý½øÐÐÒ»´ÎÐÔ²éÑ¯
 633          *
 634          * Arguments  : ÎÞ
 635          *
 636          * Returns    : ÎÞ
 637          *********************************************************************************************************
 638          */
 639          void execRFParamQ()
 640          {
 641   1        unsigned char i;  
 642   1        unsigned int CKS = 0;
 643   1      //  unsigned int selCurr;
 644   1        static unsigned int tmpCurr=0; 
 645   1      
 646   1        tmpCurr = (tmpCurr + PA_current + PA_current)/3;           //µçÁ÷ÖµÓëÇ°ÖµÆ½¾ù
 647   1      
 648   1      //  if (  PA_current > 400 )
 649   1      //    selCurr = tmpCurr;
 650   1      //  else
 651   1      //    selCurr = PA_current;
 652   1      
 653   1        if(RxBuf[7]==0)                   //¶¨Ê±Êý¾Ý²éÑ¯
 654   1        {
 655   2          RxBuf[1] = 18;                  //Êý¾Ý°ü³¤¶È
 656   2          RxBuf[4] = 16;                  //¼à¿Ø¶ÔÏóµÄ³¤¶È
 657   2          
 658   2          RxBuf[8] = Lim_state;
 659   2          RxBuf[9] = gRFSW;
 660   2          RxBuf[10] = gRFSW;
 661   2          RxBuf[11] = (unsigned char)tmpCurr;       //µÍÎ»ÔÚÇ°
 662   2          RxBuf[12] = (unsigned char)(tmpCurr>>8);    //¸ßÎ»ÔÚºó
 663   2          RxBuf[13] = (unsigned char)OutputPwr;
 664   2          RxBuf[14] = (unsigned char)(OutputPwr>>8);
 665   2            RxBuf[15] = (unsigned char)re_Pwr;
 666   2          RxBuf[16] = (unsigned char)(re_Pwr>>8);
 667   2          RxBuf[17] = (char)gcurRfTemp;
 668   2          RxBuf[18] = (char)(gcurRfTemp>>8);  
 669   2          RxBuf[19] = PLL_state;                //080220 Ôö¼Ó
 670   2          Data_len = 20;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 12  

 671   2        }
 672   1        else if(RxBuf[7]==1)                  //¹¤³§²ÎÊý²éÑ¯Êý¾Ý°ü
 673   1        {   
 674   2          RxBuf[1] = 94;                  //Êý¾Ý°ü³¤¶È            
 675   2          RxBuf[4] = 92;                  //¼à¿Ø¶ÔÏóµÄ³¤¶È
 676   2                      
 677   2          readE2promStr(5,EE_AtteVal,&RxBuf[10]);     //ÔöÒæ²ÎÊý    
 678   2          readE2promStr(4,EE_Att1slopeval,&RxBuf[15]);
 679   2          readE2promStr(11,EE_gPALim,&RxBuf[19]);     //¹¦·Å²ÎÊý
 680   2          readE2promStr(3,EE_gPALimNumer,&RxBuf[30]);   
 681   2          readE2promStr(20,EE_BandWidth,&RxBuf[37]);    //ÆµÂÊ²ÎÊý
 682   2          readE2promStr(4,EE_gPBmFreq,&RxBuf[57]);
 683   2          readE2promStr(14,EE_CurCo,&RxBuf[61]);      //µçÁ÷²ÎÊý    
 684   2          readE2promStr(4,EE_GainNumer,&RxBuf[75]);   //ÎÂ¶È²ÎÊý    
 685   2          readE2promStr(3,EE_RF_No,&RxBuf[79]);     //Ä£¿é²ÎÊý
 686   2          
 687   2          //test  palim
 688   2          //RxBuf[19] = (unsigned char)gPALim;
 689   2          //RxBuf[20] = (unsigned char)(gPALim >> 8);
 690   2          //test palim
 691   2          
 692   2          swapBytes((unsigned char *)&gCenFreq,&RxBuf[33],4);   
 693   2          //RxBuf[12] = 0;
 694   2          //RxBuf[13] = 0;
 695   2          RxBuf[80] = gRFSW;
 696   2          RxBuf[81] = gRFSW;
 697   2          RxBuf[82] = Ver_Low;
 698   2          RxBuf[83] = Ver_High;
 699   2          RxBuf[84] = (unsigned char)all_checksum;
 700   2          RxBuf[85] = (unsigned char)(all_checksum >> 8);
 701   2          readE2promStr(10,EE_MODULE_No,&RxBuf[86]);      //Ä£¿é²ÎÊý    
 702   2            watchdog();
 703   2          for(i=0;i<86;i++)
 704   2          {
 705   3            CKS += RxBuf[10+i];
 706   3          } 
 707   2          watchdog(); 
 708   2          RxBuf[8] = (unsigned char)CKS;
 709   2          RxBuf[9] = (unsigned char)(CKS>>8);
 710   2          
 711   2          Data_len = 96; 
 712   2        }
 713   1        else
 714   1        {
 715   2          ack_flag = OC_ERR;              
 716   2        }   
 717   1      }
 718          /*
 719          *********************************************************************************************************
 720          *                         Êý¾Ý°ü±àÂë            
 721          *
 722          * Description: ¶Ô°üÊý¾Ý½øÐÐ±àÂë,ack°üÖÃÓÚreadXPktBufÖÐ
 723          *        ±¾º¯Êý±ØÐëÎª¿ÉÖØÈëµÄ
 724          *
 725          * Arguments  : X_PACKETÖ¸Õë£¬Ö¸ÏòÐèÒª´¦ÀíµÄ°üÖ¸Õë£¬Î´½øÐÐCRCÐ£Ñé
 726          *
 727          * Returns    : ÎÞ
 728          *********************************************************************************************************
 729          */
 730          void sendPkt()
 731          {
 732   1        unsigned char *tmpPtr;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 13  

 733   1        unsigned char calPktChecksum;
 734   1        unsigned char x;
 735   1        tmpPtr = TxBuf; 
 736   1        *tmpPtr++= 0x00;                  //ÏÈ·¢Ö÷»úµØÖ·£¬¹Ì¶¨Îª0x00                      
 737   1        *tmpPtr++= 0x55;                  //°üÆðÊ¼±êÖ¾
 738   1        *tmpPtr++= 0xAA;
 739   1        memcpy(tmpPtr,RxBuf,Data_len);            //Õû¸ö°üµÄÊý¾Ý³¤¶È£¬°üÀ¨ÆðÊ¼±êÖ¾
 740   1          calDefcksum(tmpPtr,Data_len,&calPktChecksum);     //¼ÆËãÒì»òÐ£ÑéºÍ
 741   1        tmpPtr  += Data_len;
 742   1        *tmpPtr++= calPktChecksum;
 743   1      //  *tmpPtr++= 0x00;                                  //ÎÞÓÃ×Ö½Ú
 744   1        TB8 = 0x00;                     //µÚÒ»¸ö×Ö½ÚÎªµØÖ·×Ö½Ú£¬TB8±ØÐëÎª1
 745   1        Tx_ptr = 0;
 746   1      //  RDE = 1;             //ÓÃÔÚ485Í¨ÐÅÊ¹ÄÜ£¬×Ï¹âÕâÀïÃ»ÓÐÊ¹ÓÃRDE
 747   1        for(x=0;x<0x80;x++)
 748   1        {
 749   2        }
 750   1        SBUF =  TxBuf[Tx_ptr];
 751   1        pack_valid = 0;       
 752   1      
 753   1      }
 754          
 755          /*
 756          *********************************************************************************************************
 757          *                         Èí¼þÏÂÔØ³É¹¦»ò²éÑ¯Ä£¿éÐÅÏ¢            
 758          *
 759          * Description: ±êºÅ·ÖÅäÎª0x0AFD£¬Èí¼þÏÂÔØÍê³ÉÒª½«³ÌÐò´ÓEEPROMÖÐ¶Á³öµ½flashÖÐ£¬²¢³ÌÐò×ªÒÆµ½0x0000Ö´ÐÐ
 760          *
 761          * Arguments  : ÎÞ
 762          *
 763          * Returns    : ÎÞ
 764          *********************************************************************************************************
 765          */
 766          unsigned char endDwnldSoft()
 767          { 
 768   1        unsigned int checksum = 0;
 769   1        unsigned int count;
 770   1        unsigned int i,j;
 771   1        unsigned char leaveCnt;
 772   1        unsigned char err;
 773   1        unsigned int tmpInt;
 774   1        unsigned int y;  //x,
 775   1        
 776   1        count = 0x3700 - softLen;
 777   1        leaveCnt =count%32;               //²»×ã32×Ö½ÚµÄÊýÄ¿
 778   1        count = count >> 5; 
 779   1        
 780   1        if( leaveCnt != 0)                  //²»Âú32×Ö½Ú
 781   1        {
 782   2          XmtDat[1] =  (unsigned char)softLen ;
 783   2          XmtDat[0] =  (unsigned char)(softLen>>8) ;
 784   2          for(i=0;i<leaveCnt;i++)
 785   2          {
 786   3              XmtDat[2+i] = 0xFF;
 787   3          }
 788   2          watchdog();
 789   2          err = ISendStrExt(0xA0,XmtDat,leaveCnt+2);
 790   2            if( err == FALSE )
 791   2          {
 792   3            return OTHER_ERR;             //E2PROM´í
 793   3          }
 794   2        }  
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 14  

 795   1        for(j=0;j<count;j++)
 796   1        {
 797   2          err = 0;    
 798   2      /*    for(x=0;x<0x05;x++)
 799   2          {
 800   2            for(y=0;y<0xFFFF;y++);
 801   2          }*/
 802   2          for(y=0;y<20000;y++);      
 803   2          tmpInt = softLen + leaveCnt + j * 32;
 804   2            XmtDat[1] = (unsigned char)tmpInt;
 805   2          XmtDat[0] = (unsigned char)(tmpInt>>8);
 806   2      
 807   2          for(i=0;i<32;i++)
 808   2          {
 809   3              XmtDat[2+i] = 0xFF;
 810   3          }
 811   2          watchdog();
 812   2          err = ISendStrExt(0xA0,XmtDat,34);      
 813   2          if( err == FALSE )
 814   2          {
 815   3            return OTHER_ERR;             //E2PROM´í
 816   3          }   
 817   2        }  
 818   1        gDownFlag = 0xFF;
 819   1        writeE2promStr(1,EE_DOWN_FLAG,&gDownFlag);      //ÏÂÔØÊ±Ìí¼ÓÏÂÔØ±êÖ¾µÄÉèÖÃ 20090415 by zxl
 820   1      
 821   1        WP = 1;                       //´ò¿ªÐ´±£»¤£¬Ð¾Æ¬Ö»¿É¶Á
 822   1        EA = 0;
 823   1      
 824   1        FMCON = 0x08;
 825   1        FMDATA = 0x96;        //WE=1   ´ò¿ªflashÐ´Ê¹ÄÜ
 826   1        while((FMCON&0x0F)!=0);
 827   1        
 828   1        FMCON = 0x67;
 829   1        FMDATA = 0x96;        //CWP=0
 830   1        while((FMCON&0x0F)!=0);    
 831   1      
 832   1        FMADRL = 0x02;
 833   1        FMCON = 0x6C;
 834   1        FMDATA = 0x37;        //Æô¶¯ÏòÁ¿0x37  
 835   1        while((FMCON&0x0F)!=0);
 836   1        
 837   1        FMADRL = 0x03;        //×´Ì¬×Ö½Ú
 838   1        FMCON = 0x6C;       //·ÃÎÊÓÉFMADRL Ñ°Ö·µÄÓÃ»§ÅäÖÃÐÅÏ¢
 839   1        FMDATA = 0x61;        //CWP=1 AWP=1  BSB=1  
 840   1        while((FMCON&0x0F)!=0);
 841   1        
 842   1        while(1);
 843   1        //AUXR1 = 8;    
 844   1      
 845   1          return TRUE;    
 846   1      }
 847          /*
 848          *********************************************************************************************************
 849          *                         RFÄ£¿éÈí¼þÏÂÔØ            
 850          *
 851          * Description: ±êºÅ·ÖÅäÎª0x0AFE£¬¶ÔÉäÆµÄ£¿éµÄ³ÌÐò½øÐÐÔÚÏµÍ³Éý¼¶
 852          *
 853          * Arguments  : ÎÞ
 854          *
 855          * Returns    : ÎÞ
 856          *********************************************************************************************************
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 15  

 857          */
 858          unsigned char execDwnldSoft()
 859          {
 860   1        unsigned char xdata *tmpPtr = RxBuf;          //Ö¸ÏòÔ´Êý¾ÝµÄÖ¸Õë
 861   1        unsigned int idata curSoftPktSn;            //µ±Ç°Èí¼þ°üÐòºÅ£¬16Î»ÊýµÄÁÙÊ±±äÁ¿
 862   1          unsigned char idata err;    
 863   1        unsigned int idata total_len;
 864   1        unsigned char idata i;
 865   1        unsigned int idata datadrs;
 866   1        
 867   1        tmpPtr += 7;                      //È¡µ½Êý¾ÝµÄ¿ªÍ·£¬°üÐòºÅ
 868   1        swapBytes(tmpPtr, (unsigned char *)&curSoftPktSn,2);  //È¡µ½°üÐòºÅÖÃÓÚcurSoftPktSnÖÐ  
 869   1        tmpPtr += 2;                      //Ö¸ÕëÖ¸ÏòÊý¾Ý³¤¶È
 870   1        swapBytes(tmpPtr, (unsigned char *)&total_len,2);   //È¡µ½Êý¾Ý³¤¶È  
 871   1        tmpPtr += 2;                      //Ö¸ÏòÊý¾Ý²¿·Ö
 872   1        if(curSoftPktSn == 0)                 //µÚÒ»¸ö°ü
 873   1        {
 874   2          if( total_len != 0x1C )               //È¡µÃÊý¾Ý³¤¶È²¢Ö¸ÏòÆðÊ¼µØÖ·
 875   2          {                                          
 876   3            return OTHER_ERR;               //ÆäËû´íÎó
 877   3          }
 878   2          tmpPtr += 24;//0x18;                    //Ö¸ÕëÖ¸ÏòÎÄ¼þCHECKSUM×Ö½Ú
 879   2          swapBytes(tmpPtr, (unsigned char *)&softChecksum,2);//È¡µÃchechsum£¬±£´æÓÚsoftChecksum
 880   2          nextSoftPktSn = 1;
 881   2          softDownLoad = DOING;
 882   2          WP = 0;                       //¹Ø±ÕÐ´±£»¤£¬Ð¾Æ¬¿É¶Á¿ÉÐ´
 883   2          softLen = 0;
 884   2        }
 885   1        else                            //·ÇµÚÒ»°ü
 886   1        { 
 887   2          //dataLen = *tmpPtr++;
 888   2          if(curSoftPktSn != nextSoftPktSn)         //Ð£Ñé°üÐòºÅ    
 889   2          {
 890   3            return OTHER_ERR;               //°üÐòºÅ´í
 891   3          }
 892   2          if(total_len>32)
 893   2          {
 894   3            return OTHER_ERR;               //³¬³öÒ»Ò³Ð´Êý¾Ý·¶Î§,Ò»Ò³Ð´32¸ö×Ö½Ú 
 895   3          } 
 896   2          datadrs = curSoftPktSn - 1;
 897   2          datadrs = datadrs * 32;
 898   2          XmtDat[1] =  (unsigned char)datadrs;        //µÍ8Î»Íâ²¿EEPROMµØÖ·
 899   2          XmtDat[0] =  (unsigned char)(datadrs>>8);     //¸ß8Î»Íâ²¿EEPROMµØÖ·   
 900   2          for(i=0;i<total_len;i++)
 901   2          {
 902   3              XmtDat[2+i] = *(tmpPtr+i);
 903   3          }
 904   2          watchdog();
 905   2          err = ISendStrExt(0xA0,XmtDat,total_len+2);     //´æÒ»°üÊý¾Ýµ½Íâ²¿EEPROM
 906   2          watchdog();
 907   2          if( err == FALSE )
 908   2          {
 909   3            return OTHER_ERR;               //E2PROM´í
 910   3          }   
 911   2          softLen += total_len;               //¼ÆËãÈí¼þ×Ü³¤
 912   2          
 913   2          if(curSoftPktSn==3)                 //µÚÈý°üÊý¾ÝÎª¼ìÑéÊý¾Ý
 914   2          {
 915   3            for( i = 0; i < 8; i++ )
 916   3            {
 917   4              if(RxBuf[11+i]!= factry[i])
 918   4              {
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/21/2014 13:18:03 PAGE 16  

 919   5                WP = 1;
 920   5                return OTHER_ERR;           //E2PROM´í  
 921   5              }
 922   4            } 
 923   3          }  
 924   2          nextSoftPktSn++;
 925   2        } 
 926   1        return NO_ERR;                      //ÆäËû´íÎó
 927   1      }
 928          
 929          
 930          /*¼ÆËãÒì»òÐ£ÑéºÍ*/
 931          void calDefcksum(unsigned char *ptr, unsigned int len, unsigned char *checksum) small
 932          {
 933   1        unsigned char xdata tmpChecksum = 0;
 934   1      
 935   1        while(len--)
 936   1        {
 937   2          tmpChecksum ^= *ptr++;
 938   2        }
 939   1        *checksum = tmpChecksum;  
 940   1      }
 941          /*
 942          *********************************************************************************************************
 943          *                         ×Ö½ÚË³Ðò½»»»
 944          *
 945          * Description: ×Ö½ÚÁ÷Ë³Ðò½»»»£¬ÓÉÓÚÐ­ÒéÖÐ´óÓÚ2×Ö½ÚµÄÊý¾ÝµÍÎ»ÔÚÇ°£¬¸ßÎ»ÔÚºó£¬ËùÒÔÐèÒª×Ö½Ú½»»»
 946          *
 947          * Arguments  : 
 948          *        result Ö¸Õë£¬Ö¸Ïò´¦ÀíÄ¿±ê
 949          *        src      Ö¸Õë£¬Ö¸ÏòÐèÒª´¦ÀíµÄ×Ö·û´®
 950          *
 951          * Returns    : ÎÞ
 952          *********************************************************************************************************
 953          */
 954          void swapBytes(unsigned char *src, unsigned char *result,unsigned char num)
 955          {
 956   1        unsigned char i;
 957   1        src += (num-1);
 958   1        for(i=0;i<num;i++)
 959   1        {
 960   2          *result++ = *src--; 
 961   2        }
 962   1      }
 963          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3153    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3      53
   IDATA SIZE       =   ----       8
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
