C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE BRO20W_PACKET
OBJECT MODULE PLACED IN .\OUTPUT\bro20W_packet.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE APP\bro20W_packet.c OPTIMIZE(9,SIZE) REGFILE(.\OUTPUT\test.OR
                    -C) BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT(.\list\bro20W_packet.lst) TABS(2) OBJECT(.\OUTPUT\bro2
                    -0W_packet.obj)

line level    source

   1          
   2          /**-------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
   3          **ÎÄ   ¼þ   Ãû: packet.c
   4          **´´   ½¨   ÈË: ³ÌÝººì 
   5          **°æ        ±¾: V1.0
   6          **ÈÕ¡¡      ÆÚ: 2006Äê9ÔÂ30ÈÕ
   7          **×î ÐÂ °æ  ±¾: V1.6
   8          **Ãè        Êö:     ¶Ô°üµÄ½âÊÍ£¬²¢´¦Àí,²¢²Ù×÷ÉäÆµ¿ª¹Ø£¬PLLµÈ
   9          **
  10          ********************************************************************************************************/
  11          
  12          #include <reg938.h>
  13          #include <stdio.h>
  14          #include <string.h>   
  15          #include <I2C.h>
  16          #include <SPI.h>
  17          #include <cpu.h>
  18          #include <serial.h>
  19          #include <task.h>
  20          #include <packet.h>
  21          #include <bro20W_RFparam.h>
  22          #include <bro20W_RFcontrol.h>
  23          #include <e2prom.h>
  24          #include <readad.h>
  25          #include <timer.h>
  26          //#include "flash_config.h"
  27          //#include "compiler.h"
  28          //#include "flash_api.h"
  29          
  30          /*Èí¼þÏÂÔØ*/
  31          static unsigned int xdata nextSoftPktSn;        //ÇëÇóÈí¼þÏÂÔØ°üµÄÐòºÅ
  32          static unsigned int xdata preSoftChecksum = 0xFFFF;   //Ç°´ÎÏÂÔØÈí¼þµÄÐ£ÑéºÍ
  33          static unsigned int xdata softChecksum;         //Õû¸öÈí¼þµÄchecksumÖµ
  34          static unsigned int xdata softLen = 0;          //Èí¼þ×Ü³¤¶È
  35          //static unsigned char idata pktDataBuf[32];
  36          unsigned char code factry[8]={0xF0,0xD8,0x80,0xA8,0x5F,0xE0,0x87,0xC9}; 
  37          #if debug == 1
                unsigned char code debugstr[17]={0x01,0x0F,0xA0 ,0xFF ,0x0D ,0xDA ,0x0A ,0x01 ,0x00 ,0x00 ,0x40 ,0x00 ,0x
             -04 ,0xE8 ,0xAF ,0x0D ,0x00};
              #endif 
  40          
  41          /*
  42          *********************************************************************************************************
  43          *                         Êý¾Ý°ü½âÂë            
  44          *
  45          * Description: ¶ÔreadXPktBufÖÐµÄÊý¾Ý½øÐÐ½âÂë£¬°üÀ¨¶þ×Ö²ð·Ö£¬Çø·ÖÃüÁîºÍÊý¾Ý£¬È¡µÃCRCÖµ
  46          *
  47          * Arguments  : ÎÞ
  48          *
  49          * Returns    : ÎÞ
  50          *********************************************************************************************************
  51          */
  52          void execute_cmd() 
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 2   

  53          {
  54   1        unsigned char resultCode = NO_ERR;    
  55   1        unsigned char downresult = NO_ERR;
  56   1        switch(RxBuf[5])
  57   1        {
  58   2          case 0xDA:                    //²éÑ¯ºÍÉèÖÃ¹¤³§²ÎÊý
  59   2          {
  60   3            execFctParamSet();  
  61   3            break;
  62   3            }
  63   2          case 0xF0:                    //RFÄ£ ¿éÉäÆµ£¨¹¤³§£©²ÎÊý²éÑ¯   
  64   2          {
  65   3            execRFParamQ();
  66   3            break;
  67   3          }
  68   2          case 0xFD:                    //Èí¼þÏÂÔØÈ·ÈÏ»ò²éÑ¯Ä£¿éÐÅÏ¢  
  69   2          {
  70   3            if(RxBuf[7]==0x01)
  71   3            {
  72   4              if(RxBuf[8]==0)             //ÏÂÔØÈ¡Ïû
  73   4              {
  74   5                Data_len = 10;
  75   5                softDownLoad = UNDO;
  76   5              }
  77   4              else                  //ÏÂÔØÈ·ÈÏ
  78   4              {
  79   5                if(softDownLoad == DOING)
  80   5                {
  81   6                  downresult = endDwnldSoft();
  82   6                  RxBuf[6] |= downresult;       //´íÎó´úÂë±êÖ¾
  83   6                }
  84   5                else
  85   5                {
  86   6                  RxBuf[6] |= OTHER_ERR;        //´íÎó´úÂë±êÖ¾
  87   6                }
  88   5                Data_len = 10;
  89   5              }
  90   4            }
  91   3            break;
  92   3          }
  93   2          case 0xFE:                    //Èí¼þÏÂÔØ      
  94   2          {
  95   3              DwnldSoft1m_time = getTime();
  96   3            resultCode = execDwnldSoft();
  97   3            RxBuf[1] = 9;               //Êý¾Ý°ü³¤¶È   
  98   3            RxBuf[4] = 7;
  99   3            RxBuf[6] |= resultCode;           //´íÎó´úÂë±êÖ¾
 100   3            RxBuf[9] = (unsigned char)nextSoftPktSn;
 101   3            RxBuf[10] = (unsigned char)(nextSoftPktSn>>8);
 102   3            Data_len = 11;
 103   3            break;
 104   3          }
 105   2          case 0xFB:
 106   2          {
 107   3            if(RxBuf[7] == 0x01)
 108   3            {
 109   4              AUXR1 = 8;                                //Èí¼þ¸´Î»   20080618
 110   4            }
 111   3            break;
 112   3          }
 113   2        
 114   2          default:                    //ÃüÁî±àºÅ´í
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 3   

 115   2          {
 116   3            RxBuf[6] |= OCID_ERR;           //¼à¿Ø¶ÔÏó±êºÅÎÞ·¨Ê¶±ð  
 117   3            break;
 118   3          }
 119   2        } 
 120   1      }
 121          
 122          /*
 123          *********************************************************************************************************
 124          *                         Êä³ö¹¦ÂÊ²ÉÑù            
 125          *
 126          * Description: 
 127          *
 128          * Arguments  : ÎÞ
 129          *
 130          * Returns    : ÎÞ
 131          *********************************************************************************************************
 132          */
 133          void OutputPwrsampling()
 134          {
 135   1        unsigned char temp[4];
 136   1        unsigned char gPReadADNumerN;
 137   1        unsigned char i;
 138   1        int calVal;
 139   1      
 140   1        OutputPwr = 0;
 141   1      
 142   1        for(i=0;i<8;i++)
 143   1        {
 144   2          OutputPwr += readAD(CHANNEL_0);
 145   2        }
 146   1        
 147   1        OutputPwr >>= 3;
 148   1      
 149   1        readE2promStr(1,EE_gPReadADNumer,temp);     //¶ÁÈ¡ ¹¦ÂÊ¶ÁÈ¡²¹³¥·Ö×Ó         
 150   1        swapBytes(temp,(unsigned char *)&gPReadADNumer,1);
 151   1      
 152   1        readE2promStr(1,EE_gPequDenomi,temp);     //¶ÁÈ¡ ¹¦ÂÊ²¹³¥·ÖÄ¸         
 153   1        swapBytes(temp,(unsigned char *)&gPequDenomi,1);
 154   1      
 155   1        //readE2promStr(4,EE_CenFreq,temp);       //¶ÁÈ¡ ÖÐÐÄÆµÂÊ
 156   1        //swapBytes(temp,(unsigned char *)&gCenFreq,4);
 157   1      
 158   1          readE2promStr(4,EE_gPBmFreq,temp);        //¶ÁÈ¡ »ù×¼ÆµÂÊ
 159   1        swapBytes(temp,(unsigned char *)&gPBmFreq,4);
 160   1      
 161   1        gPReadADNumerN = ~gPReadADNumer + 1;
 162   1      
 163   1        calVal = OutputPwr;
 164   1        if(gCenFreq < gPBmFreq)
 165   1        {
 166   2          if(gPReadADNumer < 0)
 167   2          {
 168   3            calVal += (gPBmFreq - gCenFreq) * gPReadADNumerN / (gPequDenomi * 1000);
 169   3          }
 170   2          else
 171   2          {
 172   3            calVal -= (gPBmFreq - gCenFreq) * gPReadADNumer / (gPequDenomi * 1000);
 173   3          }
 174   2        }                 
 175   1        else if(gPBmFreq < gCenFreq)
 176   1        {
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 4   

 177   2          if(gPReadADNumer < 0)
 178   2          {
 179   3            calVal -= (gCenFreq - gPBmFreq) * gPReadADNumerN / (gPequDenomi * 1000);
 180   3          }
 181   2          else
 182   2          {
 183   3            calVal += (gCenFreq - gPBmFreq) * gPReadADNumer / (gPequDenomi * 1000);
 184   3          }
 185   2        }
 186   1      
 187   1        //ÅÐ¶Ï·¶Î§£¬·ÀÖ¹Òç³ö
 188   1        if(calVal < 0)
 189   1        {
 190   2          OutputPwr = 0;
 191   2        }
 192   1        else if(calVal > 1023)
 193   1        {
 194   2          OutputPwr = 1023;
 195   2        }
 196   1        else
 197   1        {
 198   2          OutputPwr = calVal;
 199   2        }
 200   1      
 201   1      }
 202          /*
 203          *********************************************************************************************************
 204          *                         ¶¨Ê±²éÑ¯¸æ¾¯ÐÅÏ¢            
 205          *
 206          * Description: 
 207          *
 208          * Arguments  : ÎÞ
 209          *
 210          * Returns    : ÎÞ
 211          *********************************************************************************************************
 212          */
 213          void updateAlmInfo() small
 214          {
 215   1        unsigned char i;
 216   1        static unsigned char preRFSW;
 217   1      //  static unsigned char gRFSWtemp = 0;
 218   1      //  unsigned char tempNum;
 219   1      
 220   1        //preRFSW = gRFSW;                        //·ÅÔÚ²Ù×÷ÉäÆµ¿ª¹ØÖ®ºó
 221   1      
 222   1        PA_current = 0;
 223   1        re_Pwr =0;
 224   1        OutputPwr = 0;  
 225   1      
 226   1        if(gRFSW == CLOSE)
 227   1        {
 228   2          Lim_state = 0;                //ÉäÆµ¿ª¹Ø¹Ø±ÕÊ±ÏÞ·ù×´Ì¬ÎªÕý³£
 229   2        }
 230   1        else
 231   1        { 
 232   2          Lim_state = (LimYes == 0 ? FALSE : TRUE );  //¼ì²âÏÞ·ù×´Ì¬
 233   2        }
 234   1          
 235   1        PLL_state = (LockYes == 1 ? FALSE : TRUE);    //¼ì²âÊ§Ëø×´Ì¬
 236   1         
 237   1        watchdog();
 238   1            
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 5   

 239   1        if(AutoSwitch == CLOSE)               //ÆµÂÊÃ»Ëø¶¨»òÕßÊÖ¶¯Ç¿ÖÆ¹Ø±ÕÔò¹Ø±Õ¹¦·Å
 240   1        {
 241   2          gRFSW = CLOSE;
 242   2          TempOverAlm = 0;
 243   2        }
 244   1        else
 245   1        {
 246   2          if(gcurRfTemp > 2*gPAProtecttLim)
 247   2          {
 248   3            gRFSW = CLOSE;
 249   3            TempOverAlm = 1;
 250   3          }
 251   2          else 
 252   2          if(gcurRfTemp < 2*gPAResetLim)
 253   2          {
 254   3            gRFSW = OPEN;
 255   3            TempOverAlm = 0;             
 256   3          }
 257   2        }
 258   1        
 259   1        switchRF(gRFSW);
 260   1          
 261   1        if(preRFSW != gRFSW)                //¿ª¹Ø±ä»¯ÔòÖØÐ´ËøÏà»·
 262   1        {
 263   2          writePLL();
 264   2            if(gRFSW==OPEN)
 265   2           {
 266   3             delay(2);   
 267   3           }
 268   2        }
 269   1        preRFSW = gRFSW;
 270   1      
 271   1        /*for(i=0;i<20;i++)                              //ÏÈ¶Á100´Î²¢ÇÒ¶ªÆú£¬¼Ó¿ì²ÉÑùËÙ¶È
 272   1        {
 273   1          readAD(CHANNEL_0);
 274   1          readAD(CHANNEL_1);              //¶Á·´Éä¹¦ÂÊADÖµ
 275   1          readAD(CHANNEL_5);
 276   1        } */
 277   1      
 278   1        for(i=0;i<8;i++)
 279   1        {
 280   2          re_Pwr += readAD(CHANNEL_1);        //¶Á·´Éä¹¦ÂÊADÖµ
 281   2          PA_current += readAD(CHANNEL_5);      //¶Á³ö¹¦·ÅµçÁ÷ADÖµ
 282   2        }
 283   1      
 284   1        re_Pwr >>= 3;
 285   1        PA_current >>= 3;
 286   1        OutputPwrsampling();              //ÕýÏò¹¦ÂÊµÄ¶ÁÈ¡
 287   1        AD0CON = 0x01;              //¹Ø±Õ×ª»»£¬ÒÔ·ÀÖ¹³öÏÖ¹Ü½ÅÏà»¥Ó°ÏìÏÖÏó¡£add by dw   20090623
 288   1          
 289   1      #if debug == 1
                memcpy(RxBuf,debugstr,17);
                pack_valid = 1;
              #endif
 293   1      
 294   1        watchdog();           
 295   1      }
 296          /*
 297          *********************************************************************************************************
 298          *                         ¹¤³§²ÎÊýÉèÖÃÃüÁî            
 299          *
 300          * Description: ±êºÅ·ÖÅäÎª0x0ADA£¬¶Ô¸÷¸ö¹¤³§²ÎÊý½øÐÐÉèÖÃ£¬²éÑ¯ÔÚÁíÒ»ÃüÁîÖÐ
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 6   

 301          *
 302          * Arguments  : ÎÞ
 303          *
 304          * Returns    : ÎÞ
 305          *********************************************************************************************************
 306          */
 307          void execFctParamSet()
 308          {
 309   1      
 310   1        unsigned char tempLen;//,bufPoint;
 311   1        unsigned short param_addr;//,j;//,j;                      //²ÎÊý¶ÔÓ¦µÄEEPROMµØÖ·
 312   1        unsigned short tmpInt=0;//j;
 313   1      //  unsigned long tmpLong=0;
 314   1        unsigned char temp[4];
 315   1        unsigned short tPALim;
 316   1        
 317   1        param_addr = RxBuf[10];
 318   1        param_addr += (RxBuf[11]<<8);                  //²ÎÊý¶ÔÓ¦µÄEEPROMµØÖ·
 319   1      
 320   1        tempLen = RxBuf[12];
 321   1        
 322   1        tPALim = gPALim;
 323   1      
 324   1        if(RxBuf[7]==0)                   //¹¤³§²ÎÊý²éÑ¯
 325   1        { 
 326   2          readE2promStr(tempLen,param_addr,&RxBuf[13]);            //Ò»°ã²ÎÊýÔÚE2PROMÖÐ¶ÁÈ¡
 327   2              
 328   2          switch(param_addr)                                          //¸ö±ð²ÎÊýÔòÐèÒªÊµÊ±²éÑ¯
 329   2          {
 330   3            case 0x0040:
 331   3              if ( RFSrcSelect )
 332   3              {
 333   4                RxBuf[13] = 0,RxBuf[14] = 0,RxBuf[15] = 0,RxBuf[16] = 0;
 334   4              }
 335   3              break;
 336   3            case EE_DA_CHANNEL_B:               
 337   3              RxBuf[13] = gDAoutB*gRFSW;
 338   3              RxBuf[14] = (gDAoutB*gRFSW)>>8;
 339   3              break;
 340   3            case EE_DA_CHANNEL_C:
 341   3              RxBuf[13] = gDAoutC*gRFSW;
 342   3              RxBuf[14] = (gDAoutC*gRFSW)>>8;
 343   3              break;
 344   3            case 0x00A4:
 345   3              IRcvStr(0x90,0x03,temp,2);         //0x90 ÓÉ1 £¬0 £¬0 £¬1 ,  A2  £¬A1£¬ A0£¬R/W ×é³É£¬¸ßËÄÎ»¹Ì¶¨£¬µÍËÄ
             -Î»ÊÇµØÖ·Î»¡¢¶ÁÐ´Î»
 346   3              RxBuf[13] = temp[0];                  //0x03±íÊ¾Òª¶ÁÈ¡µÄIICÆ÷¼þÄÚ²¿¼Ä´æÆ÷µØÖ·
 347   3              break;
 348   3            case 0x00A5:
 349   3              IRcvStr(0x90,0x02,temp,2);
 350   3              RxBuf[13] = temp[0];
 351   3              break;        
 352   3      
 353   3            case 0x00C1:
 354   3            case 0x00C2:                      
 355   3              RxBuf[13] = gRFSW;
 356   3              break;
 357   3      /*        case 0x00C4:
 358   3              RxBuf[13] = PLL_state;
 359   3              break;
 360   3      
 361   3            case 0x00C5:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 7   

 362   3              RxBuf[13] = Lim_state;
 363   3              break;
 364   3            case 0x00C6:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 365   3              RxBuf[13] = (unsigned char)PA_current;
 366   3              RxBuf[14] = (unsigned char)(PA_current >> 8);
 367   3              break;
 368   3            case 0x00C7:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
 369   3              RxBuf[13] = (unsigned char)OutputPwr;
 370   3              RxBuf[14] = (unsigned char)(OutputPwr >> 8);
 371   3              break;
 372   3            case 0x00C8:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 373   3              RxBuf[13] = (unsigned char)re_Pwr;
 374   3              RxBuf[14] = (unsigned char)(re_Pwr >> 8);
 375   3              break;*/
 376   3            case 0x00CA:  
 377   3                          
 378   3              RxBuf[13] = (unsigned char)gcurRfTemp;
 379   3              RxBuf[14] = (unsigned char)(gcurRfTemp >> 8);
 380   3              break;
 381   3      
 382   3            case 0x00E0:                      //2×Ö½Ú£¬³ÌÐò°æ±¾ºÅ
 383   3              RxBuf[13] = Ver_Low;
 384   3              RxBuf[14] = Ver_High;
 385   3              break;
 386   3            case 0x00E2:                    //2×Ö½Ú£¬³ÌÐòÐ£ÑéºÍ
 387   3              RxBuf[13] = (unsigned char)all_checksum;
 388   3              RxBuf[14] = (unsigned char)(all_checksum >> 8);
 389   3              break;
 390   3              default:
 391   3                break;            
 392   3          }
 393   2        }
 394   1        else                                                    //¹¤³§²ÎÊýÉè¶¨
 395   1        {
 396   2          
 397   2          if (tempLen==2)
 398   2          {
 399   3            tmpInt = RxBuf[13];
 400   3            tmpInt += (RxBuf[14]<<8);   
 401   3          }
 402   2        
 403   2          //switch(param_addr):Ö÷ÒªÓÃÓÚ¶Ô½ÓÊÕµÄÊý¾Ý½øÐÐ¼ìÑé£¬ÊÇ·ñÎªÕý³£ÖµµÄ·¶Î§ÄÚ£¬Èô²»ÊÇ£¬Ôò²»´æÈëEEPROM
 404   2          switch(param_addr)
 405   2          {
 406   3            //2×Ö½Ú£¬¹¦·ÅÏÞ·ù
 407   3            case EE_DA_CHANNEL_B:
 408   3            case EE_DA_CHANNEL_C:
 409   3              if ( tmpInt > 1023 )
 410   3                RxBuf[6] |= DATRANGE_ERR; 
 411   3              break;
 412   3            case 0x0020:                  //2×Ö½Ú,¹¦·ÅÆ«Ñ¹Öµ      
 413   3              if( (tmpInt<0)||(tmpInt>1023) )
 414   3              {
 415   4                RxBuf[6] |= DATRANGE_ERR; 
 416   4              }
 417   3              break;                  //1×Ö½Ú£¬ÔöÒæÎÂ²¹ÏµÊý·Ö×Ó
 418   3            case 0x00A2:                  //1×Ö½Ú£¬ÔöÒæÎÂ²¹ÏµÊý·ÖÄ¸
 419   3            case 0x00A3:
 420   3              if((RxBuf[13]<0)||(RxBuf[13]>255))
 421   3              {
 422   4                RxBuf[6] |= DATRANGE_ERR; 
 423   4              }
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 8   

 424   3              break;
 425   3            case 0x00A5:                  //1×Ö½Ú£¬¹¦·ÅÖØÆðÎÂ¶ÈÏÂÏÞ   
 426   3              if((RxBuf[13]<0)||(RxBuf[13]>125))
 427   3              {
 428   4                RxBuf[6] |= DATRANGE_ERR; 
 429   4              }
 430   3              break;
 431   3            case 0x00D2:                  //1×Ö½Ú£¬µ÷ÊÔ×´Ì¬  
 432   3              if((RxBuf[13]<0)||(RxBuf[13]>2))      
 433   3              {
 434   4                RxBuf[6] |= DATRANGE_ERR; 
 435   4              }
 436   3              break;    
 437   3            case 0x00D3:                  //1×Ö½Ú£¬ÎÂ²¹»ù×¼Öµ  
 438   3              if((RxBuf[13]<0)||(RxBuf[13]>200))
 439   3              {
 440   4                RxBuf[6] |= DATRANGE_ERR; 
 441   4              }
 442   3              break;
 443   3            default:
 444   3              break;    
 445   3          }
 446   2          if(RxBuf[6]==0x0A)                  //½ÓÊÕµÄÊý¾ÝÎªÕý³£Öµ£¬Ôò¿ªÊ¼½«Êý¾Ý´æEEPROM
 447   2          {
 448   3            if(param_addr != 0x0140)
 449   3            {
 450   4              if ( param_addr == 0x0040 && tempLen == 6 )                     //2012-6-19 HANÔö
 451   4              {
 452   5                writeE2promStr(4,0x0040,&RxBuf[13]);
 453   5                writeE2promStr(2,0x0020,&RxBuf[17]);                
 454   5              }
 455   4              else                                                            //han,³¤¡¢ÃüÁîÊÇ40£¬³¤¶ÈÊÇ6£¬×öÉÏÊöÊÂ¡
             -£
 456   4              {
 457   5                writeE2promStr(tempLen,param_addr,&RxBuf[13]);      
 458   5              }
 459   4            }
 460   3            rfPramModified = TRUE;              //ÉäÆµ²ÎÊýÐÞ¸Ä±êÖ¾ÓÐÐ§  
 461   3            switch(param_addr)
 462   3            {
 463   4              case EE_DA_CHANNEL_B:
 464   4                gDAoutB = tmpInt;         
 465   4                writeAD5314(gDAoutB,'B');
 466   4              break;
 467   4              case EE_DA_CHANNEL_C:
 468   4                gDAoutC = tmpInt;
 469   4                writeAD5314(gDAoutC,'C');         
 470   4              break;
 471   4              case EE_SOURCE_SELECT:
 472   4                RFSrcSelect = (RxBuf[13] != SRC_INTERNAL && RxBuf[13] != SRC_EXTERNAL)?SRC_INTERNAL:RxBuf[13];          
 473   4                writePLL();
 474   4              break;
 475   4              //--------------------------ÔöÒæ-------------------------------
 476   4                //---------ÉÏÐÐÔöÒæ------------
 477   4              case 0x0003:
 478   4                 gGain=RxBuf[13];
 479   4                 writeAtt1(gGain);
 480   4                 updateAlmInfo();
 481   4              case 0x0020:                  //2×Ö½Ú£¬Êä³ö¹¦ÂÊÏÞ·ùÖµ                 
 482   4                //2012.10.26
 483   4                gPALimCompensate();
 484   4                gPALim = (gPALim + tPALim)/2;         
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 9   

 485   4                writeAD5314(gPALim,'A');
 486   4                updateAlmInfo();          
 487   4                
 488   4                delay(1);
 489   4                
 490   4                gPALimCompensate();
 491   4                writeAD5314(gPALim,'A');
 492   4                updateAlmInfo();
 493   4                //Task5S_time = getTime() + 100;
 494   4                break;        
 495   4              case 0x0040:                //4×Ö½Ú£¬ÖÐÐÄÆµÂÊ
 496   4              case 0x0140:
 497   4                //gCenFreq = tmpLong;
 498   4                swapBytes(&RxBuf[13],(unsigned char *)&gCenFreq,4);
 499   4                writePLL();
 500   4                delay(1);
 501   4                //gPALimCompensate();
 502   4                            //writeAD5314(gPALim,'B');         //¸Ä±äÖÐÐÄÆµÂÊÐèÒªÍ¬Ê±½øÐÐÏÞ·ù²¹³¥
 503   4      
 504   4                  /*2012.6.19 HAN add*/
 505   4                //2012.10.26
 506   4                if ( tempLen == 6 )
 507   4                {
 508   5                  gPALimCompensate();
 509   5                  gPALim = (gPALim + tPALim)/2;         
 510   5                  writeAD5314(gPALim,'A');
 511   5                  updateAlmInfo();          
 512   5                  
 513   5                  delay(1);
 514   5                  
 515   5                  gPALimCompensate();
 516   5                  writeAD5314(gPALim,'A');
 517   5                  updateAlmInfo();            
 518   5                }  
 519   4      
 520   4                break;
 521   4      
 522   4              case 0x004A:                //2×Ö½Ú£¬ÆµÂÊ²½½øÖµ
 523   4              case 0x0054:                //4×Ö½Ú£¬²Î¿¼ÆµÂÊ
 524   4                writePLL();
 525   4                break;
 526   4      
 527   4              case 0x0075:                      //¹¦ÂÊÏÞ·ù²¹³¥·Ö×Ó
 528   4      //          case 0x0076:
 529   4              case 0x0077:                      //¹¦ÂÊ²¹³¥·ÖÄ¸
 530   4              case 0x0078:                     //»ù×¼ÆµÂÊ
 531   4                //2012.10.26
 532   4                gPALimCompensate();
 533   4                gPALim = (gPALim + tPALim)/2;         
 534   4                writeAD5314(gPALim,'A');
 535   4                updateAlmInfo();          
 536   4                
 537   4                delay(1);
 538   4                
 539   4                gPALimCompensate();
 540   4                writeAD5314(gPALim,'A');
 541   4                updateAlmInfo();          
 542   4                break;
 543   4      
 544   4              case 0x00A4:                  //2×Ö½Ú£¬¹¦·Å±£»¤ÎÂ¶ÈÏÂÏÞ
 545   4                gPAProtecttLim = RxBuf[13];
 546   4                writeLM75(0x03,gPAProtecttLim,3); 
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 10  

 547   4                break;
 548   4      
 549   4              case 0x00A5:                  //2×Ö½Ú£¬¹¦·ÅÖØÆðÎÂ¶ÈÏÂÏÞ
 550   4                gPAResetLim = RxBuf[13];
 551   4                writeLM75(0x02,gPAResetLim,3);  
 552   4                break;
 553   4      
 554   4              case 0x00C0:                  //1×Ö½Ú£¬ÉäÆµÄ£¿é±àºÅ
 555   4                gRF_No = RxBuf[13]; 
 556   4                break;
 557   4      
 558   4              case 0x00C2:                  //1×Ö½Ú£¬ÉäÆµ¿ª¹Ø
 559   4                if(AutoSwitch != RxBuf[13]);
 560   4                {
 561   5                  AutoSwitch = RxBuf[13];
 562   5      
 563   5                  updateAlmInfo();
 564   5                  writeAtt1(gGain);
 565   5                  writePLL();                      //ÉäÆµ¿ª¹Ø¶¯×÷ÁË£¬Ã¿´ÎÒª´ÓÐÂ²Ù×÷ËøÏà                       ·
 566   5      /*            if(AutoSwitch == CLOSE)
 567   5                  {
 568   5                      gRFSW = CLOSE;
 569   5                    switchRF(gRFSW);
 570   5                  }
 571   5                  else if(gcurRfTemp < 2*gPAProtecttLim)
 572   5                  {*/
 573   5                      //gRFSW = OPEN;
 574   5                    //switchRF(gRFSW);
 575   5                    //Task5S_time = getTime();
 576   5      //            }
 577   5                }
 578   4                watchdog();     
 579   4                break;  
 580   4              default:
 581   4                break;                
 582   4            }
 583   3          }
 584   2        }
 585   1        Data_len = RxBuf[1] + 2;
 586   1      }
 587          
 588          void sendInitpacket()
 589          {
 590   1        readE2promStr(1,EE_DOWN_FLAG,&gDownFlag);
 591   1      
 592   1        if(gDownFlag == 0xFF)
 593   1        { 
 594   2          gDownFlag = 0x00;
 595   2          writeE2promStr(1,EE_DOWN_FLAG,&gDownFlag);     
 596   2      
 597   2          RxBuf[0] = 0x00;  //Ö÷¿Ø°åµØÖ·
 598   2          RxBuf[1] = 8;     //³¤¶È
 599   2          RxBuf[2] = 0xA0;  //ÃüÁî±êÊ¶
 600   2          RxBuf[3] = 0x00;  //Ó¦´ð±êÖ¾
 601   2          RxBuf[4] = 6;   //¼à¿Ø¶ÔÏó³¤¶È
 602   2          RxBuf[5] = 0xFD;
 603   2          RxBuf[6] = 0x0A;
 604   2          RxBuf[7] = 0x01;
 605   2          RxBuf[8] = 0x01;
 606   2          RxBuf[9] = 0x01;
 607   2      
 608   2          Data_len = 10;
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 11  

 609   2      
 610   2          sendPkt();
 611   2        }
 612   1      }
 613          
 614          /*
 615          *********************************************************************************************************
 616          *                         RFÄ£¿éÉäÆµ²ÎÊý²éÑ¯            
 617          *
 618          * Description: ±êºÅ·ÖÅäÎª0x0AF0£¬¶Ô¸÷¸ö¹¤³§²ÎÊý½øÐÐÒ»´ÎÐÔ²éÑ¯
 619          *
 620          * Arguments  : ÎÞ
 621          *
 622          * Returns    : ÎÞ
 623          *********************************************************************************************************
 624          */
 625          void execRFParamQ()
 626          {
 627   1        unsigned char i;  
 628   1        unsigned int CKS = 0;
 629   1      //  unsigned int selCurr;
 630   1        static unsigned int tmpCurr=0; 
 631   1      
 632   1        tmpCurr = (tmpCurr + PA_current + PA_current)/3;           //µçÁ÷ÖµÓëÇ°ÖµÆ½¾ù
 633   1      
 634   1      //  if (  PA_current > 400 )
 635   1      //    selCurr = tmpCurr;
 636   1      //  else
 637   1      //    selCurr = PA_current;
 638   1      
 639   1        if(RxBuf[7]==0)                   //¶¨Ê±Êý¾Ý²éÑ¯
 640   1        {
 641   2          RxBuf[1] = 18;                  //Êý¾Ý°ü³¤¶È
 642   2          RxBuf[4] = 16;                  //¼à¿Ø¶ÔÏóµÄ³¤¶È
 643   2          
 644   2          RxBuf[8] = Lim_state;
 645   2          RxBuf[9] = gRFSW;
 646   2          RxBuf[10] = gRFSW;
 647   2          RxBuf[11] = (unsigned char)tmpCurr;       //µÍÎ»ÔÚÇ°
 648   2          RxBuf[12] = (unsigned char)(tmpCurr>>8);    //¸ßÎ»ÔÚºó
 649   2          RxBuf[13] = (unsigned char)OutputPwr;
 650   2          RxBuf[14] = (unsigned char)(OutputPwr>>8);
 651   2            RxBuf[15] = (unsigned char)re_Pwr;
 652   2          RxBuf[16] = (unsigned char)(re_Pwr>>8);
 653   2          RxBuf[17] = (char)gcurRfTemp;
 654   2          RxBuf[18] = (char)(gcurRfTemp>>8);  
 655   2          RxBuf[19] = PLL_state;                //080220 Ôö¼Ó
 656   2          Data_len = 20;
 657   2        }
 658   1        else if(RxBuf[7]==1)                  //¹¤³§²ÎÊý²éÑ¯Êý¾Ý°ü
 659   1        {   
 660   2          RxBuf[1] = 94;                  //Êý¾Ý°ü³¤¶È            
 661   2          RxBuf[4] = 92;                  //¼à¿Ø¶ÔÏóµÄ³¤¶È
 662   2                      
 663   2          readE2promStr(5,EE_AtteVal,&RxBuf[10]);     //ÔöÒæ²ÎÊý    
 664   2          readE2promStr(4,EE_Att1slopeval,&RxBuf[15]);
 665   2          readE2promStr(11,EE_gPALim,&RxBuf[19]);     //¹¦·Å²ÎÊý
 666   2          readE2promStr(3,EE_gPALimNumer,&RxBuf[30]);   
 667   2          readE2promStr(20,EE_BandWidth,&RxBuf[37]);    //ÆµÂÊ²ÎÊý
 668   2          readE2promStr(4,EE_gPBmFreq,&RxBuf[57]);
 669   2          readE2promStr(14,EE_CurCo,&RxBuf[61]);      //µçÁ÷²ÎÊý    
 670   2          readE2promStr(4,EE_GainNumer,&RxBuf[75]);   //ÎÂ¶È²ÎÊý    
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 12  

 671   2          readE2promStr(3,EE_RF_No,&RxBuf[79]);     //Ä£¿é²ÎÊý
 672   2          
 673   2          //test  palim
 674   2          //RxBuf[19] = (unsigned char)gPALim;
 675   2          //RxBuf[20] = (unsigned char)(gPALim >> 8);
 676   2          //test palim
 677   2          
 678   2          swapBytes((unsigned char *)&gCenFreq,&RxBuf[33],4);   
 679   2          //RxBuf[12] = 0;
 680   2          //RxBuf[13] = 0;
 681   2          RxBuf[80] = gRFSW;
 682   2          RxBuf[81] = gRFSW;
 683   2          RxBuf[82] = Ver_Low;
 684   2          RxBuf[83] = Ver_High;
 685   2          RxBuf[84] = (unsigned char)all_checksum;
 686   2          RxBuf[85] = (unsigned char)(all_checksum >> 8);
 687   2          readE2promStr(10,EE_MODULE_No,&RxBuf[86]);      //Ä£¿é²ÎÊý    
 688   2            watchdog();
 689   2          for(i=0;i<86;i++)
 690   2          {
 691   3            CKS += RxBuf[10+i];
 692   3          } 
 693   2          watchdog(); 
 694   2          RxBuf[8] = (unsigned char)CKS;
 695   2          RxBuf[9] = (unsigned char)(CKS>>8);
 696   2          
 697   2          Data_len = 96; 
 698   2        }
 699   1        else
 700   1        {
 701   2          ack_flag = OC_ERR;              
 702   2        }   
 703   1      }
 704          /*
 705          *********************************************************************************************************
 706          *                         Êý¾Ý°ü±àÂë            
 707          *
 708          * Description: ¶Ô°üÊý¾Ý½øÐÐ±àÂë,ack°üÖÃÓÚreadXPktBufÖÐ
 709          *        ±¾º¯Êý±ØÐëÎª¿ÉÖØÈëµÄ
 710          *
 711          * Arguments  : X_PACKETÖ¸Õë£¬Ö¸ÏòÐèÒª´¦ÀíµÄ°üÖ¸Õë£¬Î´½øÐÐCRCÐ£Ñé
 712          *
 713          * Returns    : ÎÞ
 714          *********************************************************************************************************
 715          */
 716          void sendPkt()
 717          {
 718   1        unsigned char *tmpPtr;
 719   1        unsigned char calPktChecksum;
 720   1        unsigned char x;
 721   1        tmpPtr = TxBuf; 
 722   1        *tmpPtr++= 0x00;                  //ÏÈ·¢Ö÷»úµØÖ·£¬¹Ì¶¨Îª0x00                      
 723   1        *tmpPtr++= 0x55;                  //°üÆðÊ¼±êÖ¾
 724   1        *tmpPtr++= 0xAA;
 725   1        memcpy(tmpPtr,RxBuf,Data_len);            //Õû¸ö°üµÄÊý¾Ý³¤¶È£¬°üÀ¨ÆðÊ¼±êÖ¾
 726   1          calDefcksum(tmpPtr,Data_len,&calPktChecksum);     //¼ÆËãÒì»òÐ£ÑéºÍ
 727   1        tmpPtr  += Data_len;
 728   1        *tmpPtr++= calPktChecksum;
 729   1      //  *tmpPtr++= 0x00;                                  //ÎÞÓÃ×Ö½Ú
 730   1        TB8 = 0x00;                     //µÚÒ»¸ö×Ö½ÚÎªµØÖ·×Ö½Ú£¬TB8±ØÐëÎª1
 731   1        Tx_ptr = 0;
 732   1      //  RDE = 1;             //ÓÃÔÚ485Í¨ÐÅÊ¹ÄÜ£¬×Ï¹âÕâÀïÃ»ÓÐÊ¹ÓÃRDE
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 13  

 733   1        for(x=0;x<0x80;x++)
 734   1        {
 735   2        }
 736   1        SBUF =  TxBuf[Tx_ptr];
 737   1        pack_valid = 0;       
 738   1      
 739   1      }
 740          
 741          /*
 742          *********************************************************************************************************
 743          *                         Èí¼þÏÂÔØ³É¹¦»ò²éÑ¯Ä£¿éÐÅÏ¢            
 744          *
 745          * Description: ±êºÅ·ÖÅäÎª0x0AFD£¬Èí¼þÏÂÔØÍê³ÉÒª½«³ÌÐò´ÓEEPROMÖÐ¶Á³öµ½flashÖÐ£¬²¢³ÌÐò×ªÒÆµ½0x0000Ö´ÐÐ
 746          *
 747          * Arguments  : ÎÞ
 748          *
 749          * Returns    : ÎÞ
 750          *********************************************************************************************************
 751          */
 752          unsigned char endDwnldSoft()
 753          { 
 754   1        unsigned int checksum = 0;
 755   1        unsigned int count;
 756   1        unsigned int i,j;
 757   1        unsigned char leaveCnt;
 758   1        unsigned char err;
 759   1        unsigned int tmpInt;
 760   1        unsigned int y;  //x,
 761   1        
 762   1        count = 0x1D00 - softLen;
 763   1        leaveCnt =count%32;               //²»×ã32×Ö½ÚµÄÊýÄ¿
 764   1        count = count >> 5; 
 765   1        
 766   1        if( leaveCnt != 0)                  //²»Âú32×Ö½Ú
 767   1        {
 768   2          XmtDat[1] =  (unsigned char)softLen ;
 769   2          XmtDat[0] =  (unsigned char)(softLen>>8) ;
 770   2          for(i=0;i<leaveCnt;i++)
 771   2          {
 772   3              XmtDat[2+i] = 0xFF;
 773   3          }
 774   2          watchdog();
 775   2          err = ISendStrExt(0xA0,XmtDat,leaveCnt+2);
 776   2            if( err == FALSE )
 777   2          {
 778   3            return OTHER_ERR;             //E2PROM´í
 779   3          }
 780   2        }  
 781   1        for(j=0;j<count;j++)
 782   1        {
 783   2          err = 0;    
 784   2      /*    for(x=0;x<0x05;x++)
 785   2          {
 786   2            for(y=0;y<0xFFFF;y++);
 787   2          }*/
 788   2          for(y=0;y<20000;y++);      
 789   2          tmpInt = softLen + leaveCnt + j * 32;
 790   2            XmtDat[1] = (unsigned char)tmpInt;
 791   2          XmtDat[0] = (unsigned char)(tmpInt>>8);
 792   2      
 793   2          for(i=0;i<32;i++)
 794   2          {
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 14  

 795   3              XmtDat[2+i] = 0xFF;
 796   3          }
 797   2          watchdog();
 798   2          err = ISendStrExt(0xA0,XmtDat,34);      
 799   2          if( err == FALSE )
 800   2          {
 801   3            return OTHER_ERR;             //E2PROM´í
 802   3          }   
 803   2        }  
 804   1        gDownFlag = 0xFF;
 805   1        writeE2promStr(1,EE_DOWN_FLAG,&gDownFlag);      //ÏÂÔØÊ±Ìí¼ÓÏÂÔØ±êÖ¾µÄÉèÖÃ 20090415 by zxl
 806   1      
 807   1        WP = 1;                       //´ò¿ªÐ´±£»¤£¬Ð¾Æ¬Ö»¿É¶Á
 808   1        EA = 0;
 809   1      
 810   1        FMCON = 0x08;
 811   1        FMDATA = 0x96;        //WE=1   ´ò¿ªflashÐ´Ê¹ÄÜ
 812   1        while((FMCON&0x0F)!=0);
 813   1        
 814   1        FMCON = 0x67;
 815   1        FMDATA = 0x96;        //CWP=0
 816   1        while((FMCON&0x0F)!=0);    
 817   1      
 818   1        FMADRL = 0x02;
 819   1        FMCON = 0x6C;
 820   1        FMDATA = 0x1D;        //Æô¶¯ÏòÁ¿0x1E  
 821   1        while((FMCON&0x0F)!=0);
 822   1        
 823   1        FMADRL = 0x03;        //×´Ì¬×Ö½Ú
 824   1        FMCON = 0x6C;       //·ÃÎÊÓÉFMADRL Ñ°Ö·µÄÓÃ»§ÅäÖÃÐÅÏ¢
 825   1        FMDATA = 0x61;        //CWP=1 AWP=1  BSB=1  
 826   1        while((FMCON&0x0F)!=0);
 827   1        
 828   1        while(1);
 829   1        //AUXR1 = 8;    
 830   1      
 831   1          return TRUE;    
 832   1      }
 833          /*
 834          *********************************************************************************************************
 835          *                         RFÄ£¿éÈí¼þÏÂÔØ            
 836          *
 837          * Description: ±êºÅ·ÖÅäÎª0x0AFE£¬¶ÔÉäÆµÄ£¿éµÄ³ÌÐò½øÐÐÔÚÏµÍ³Éý¼¶
 838          *
 839          * Arguments  : ÎÞ
 840          *
 841          * Returns    : ÎÞ
 842          *********************************************************************************************************
 843          */
 844          unsigned char execDwnldSoft()
 845          {
 846   1        unsigned char xdata *tmpPtr = RxBuf;          //Ö¸ÏòÔ´Êý¾ÝµÄÖ¸Õë
 847   1        unsigned int idata curSoftPktSn;            //µ±Ç°Èí¼þ°üÐòºÅ£¬16Î»ÊýµÄÁÙÊ±±äÁ¿
 848   1          unsigned char idata err;    
 849   1        unsigned int idata total_len;
 850   1        unsigned char idata i;
 851   1        unsigned int idata datadrs;
 852   1        
 853   1        tmpPtr += 7;                      //È¡µ½Êý¾ÝµÄ¿ªÍ·£¬°üÐòºÅ
 854   1        swapBytes(tmpPtr, (unsigned char *)&curSoftPktSn,2);  //È¡µ½°üÐòºÅÖÃÓÚcurSoftPktSnÖÐ  
 855   1        tmpPtr += 2;                      //Ö¸ÕëÖ¸ÏòÊý¾Ý³¤¶È
 856   1        swapBytes(tmpPtr, (unsigned char *)&total_len,2);   //È¡µ½Êý¾Ý³¤¶È  
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 15  

 857   1        tmpPtr += 2;                      //Ö¸ÏòÊý¾Ý²¿·Ö
 858   1        if(curSoftPktSn == 0)                 //µÚÒ»¸ö°ü
 859   1        {
 860   2          if( total_len != 0x1C )               //È¡µÃÊý¾Ý³¤¶È²¢Ö¸ÏòÆðÊ¼µØÖ·
 861   2          {                                          
 862   3            return OTHER_ERR;               //ÆäËû´íÎó
 863   3          }
 864   2          tmpPtr += 24;//0x18;                    //Ö¸ÕëÖ¸ÏòÎÄ¼þCHECKSUM×Ö½Ú
 865   2          swapBytes(tmpPtr, (unsigned char *)&softChecksum,2);//È¡µÃchechsum£¬±£´æÓÚsoftChecksum
 866   2          nextSoftPktSn = 1;
 867   2          softDownLoad = DOING;
 868   2          WP = 0;                       //¹Ø±ÕÐ´±£»¤£¬Ð¾Æ¬¿É¶Á¿ÉÐ´
 869   2          softLen = 0;
 870   2        }
 871   1        else                            //·ÇµÚÒ»°ü
 872   1        { 
 873   2          //dataLen = *tmpPtr++;
 874   2          if(curSoftPktSn != nextSoftPktSn)         //Ð£Ñé°üÐòºÅ    
 875   2          {
 876   3            return OTHER_ERR;               //°üÐòºÅ´í
 877   3          }
 878   2          if(total_len>32)
 879   2          {
 880   3            return OTHER_ERR;               //³¬³öÒ»Ò³Ð´Êý¾Ý·¶Î§,Ò»Ò³Ð´32¸ö×Ö½Ú 
 881   3          } 
 882   2          datadrs = curSoftPktSn - 1;
 883   2          datadrs = datadrs * 32;
 884   2          XmtDat[1] =  (unsigned char)datadrs;        //µÍ8Î»Íâ²¿EEPROMµØÖ·
 885   2          XmtDat[0] =  (unsigned char)(datadrs>>8);     //¸ß8Î»Íâ²¿EEPROMµØÖ·   
 886   2          for(i=0;i<total_len;i++)
 887   2          {
 888   3              XmtDat[2+i] = *(tmpPtr+i);
 889   3          }
 890   2          watchdog();
 891   2          err = ISendStrExt(0xA0,XmtDat,total_len+2);     //´æÒ»°üÊý¾Ýµ½Íâ²¿EEPROM
 892   2          watchdog();
 893   2          if( err == FALSE )
 894   2          {
 895   3            return OTHER_ERR;               //E2PROM´í
 896   3          }   
 897   2          softLen += total_len;               //¼ÆËãÈí¼þ×Ü³¤
 898   2          
 899   2          if(curSoftPktSn==3)                 //µÚÈý°üÊý¾ÝÎª¼ìÑéÊý¾Ý
 900   2          {
 901   3            for( i = 0; i < 8; i++ )
 902   3            {
 903   4              if(RxBuf[11+i]!= factry[i])
 904   4              {
 905   5                WP = 1;
 906   5                return OTHER_ERR;           //E2PROM´í  
 907   5              }
 908   4            } 
 909   3          }  
 910   2          nextSoftPktSn++;
 911   2        } 
 912   1        return NO_ERR;                      //ÆäËû´íÎó
 913   1      }
 914          
 915          
 916          /*¼ÆËãÒì»òÐ£ÑéºÍ*/
 917          void calDefcksum(unsigned char *ptr, unsigned int len, unsigned char *checksum) small
 918          {
C51 COMPILER V9.51   BRO20W_PACKET                                                         10/22/2013 09:07:10 PAGE 16  

 919   1        unsigned char xdata tmpChecksum = 0;
 920   1      
 921   1        while(len--)
 922   1        {
 923   2          tmpChecksum ^= *ptr++;
 924   2        }
 925   1        *checksum = tmpChecksum;  
 926   1      }
 927          /*
 928          *********************************************************************************************************
 929          *                         ×Ö½ÚË³Ðò½»»»
 930          *
 931          * Description: ×Ö½ÚÁ÷Ë³Ðò½»»»£¬ÓÉÓÚÐ­ÒéÖÐ´óÓÚ2×Ö½ÚµÄÊý¾ÝµÍÎ»ÔÚÇ°£¬¸ßÎ»ÔÚºó£¬ËùÒÔÐèÒª×Ö½Ú½»»»
 932          *
 933          * Arguments  : 
 934          *        result Ö¸Õë£¬Ö¸Ïò´¦ÀíÄ¿±ê
 935          *        src      Ö¸Õë£¬Ö¸ÏòÐèÒª´¦ÀíµÄ×Ö·û´®
 936          *
 937          * Returns    : ÎÞ
 938          *********************************************************************************************************
 939          */
 940          void swapBytes(unsigned char *src, unsigned char *result,unsigned char num)
 941          {
 942   1        unsigned char i;
 943   1        src += (num-1);
 944   1        for(i=0;i<num;i++)
 945   1        {
 946   2          *result++ = *src--; 
 947   2        }
 948   1      }
 949          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3072    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3      53
   IDATA SIZE       =   ----       8
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
