C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE PACKET
OBJECT MODULE PLACED IN .\OUTPUT\packet.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE APP\packet.c BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEND PRINT
                    -(.\list\packet.lst) OBJECT(.\OUTPUT\packet.obj)

stmt level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: packet.c
   3          **创   建   人: 程莺红
   4          **修   改   人: 
   5          **最后修改日期: 2006年3月28日
   6          **最 新 版  本: V1.7
   7          **描        述: 解析串口命令，并组织回复包，发送包
   8          **
   9          **--------------历史版本信息----------------------------------------------------------------------------
  10          ** 创建人: 程莺红 
  11          ** 版  本: V1.2
  12          ** 日　期: 2006年2月21日
  13          ** 描　述: 原始版本
  14          **
  15          **------------------------------------------------------------------------------------------------------
  16          ** 修改人: 程莺红 
  17          ** 版  本: V1.3
  18          ** 日　期: 2006年2月23日
  19          ** 描　述: 将非法代码校验段放到下载的第三个包进行判断，并且在下载过程中进行判断
  20          **
  21          **------------------------------------------------------------------------------------------------------
  22          ** 修改人: 程莺红 
  23          ** 版  本: V1.4
  24          ** 日　期: 2006年3月1日
  25          ** 描　述: 当查询调试状态时赋值初始化值，不从eeprom中读取
  26          **
  27          **------------------------------------------------------------------------------------------------------
  28          ** 修改人: 程莺红 
  29          ** 版  本: V1.5
  30          ** 日　期: 2006年3月15日
  31          ** 描　述: 更改了下载部分和厂家标识以及温补基准值的范围判断
  32          **
  33          **------------------------------------------------------------------------------------------------------
  34          ** 修改人: 程莺红 
  35          ** 版  本: V1.6
  36          ** 日　期: 2006年3月28日
  37          ** 描　述: 更改了对射频开关进行操作时同时对功放开关进行相同操作
  38          **
  39          **------------------------------------------------------------------------------------------------------
  40          ** 修改人: 程莺红 
  41          ** 版  本: V1.7
  42          ** 日　期: 2006年3月28日
  43          ** 描　述: 更改了对射频开关进行操作时也要将值写入功放开关对应eeprom中
  44          **
  45          ********************************************************************************************************/
  46          
  47          #include <reg938.h>
  48          #include <stdio.h>
  49          #include <string.h>       
  50          #include <I2C.h>
  51          #include <SPI.h>
  52          #include <cpu.h>
  53          #include <serial.h>
  54          #include <task.h>
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 2   

  55          #include <packet.h>
  56          #include <bro20W_RFparam.h>
  57          #include <bro20W_RFcontrol.h>
  58          #include <e2prom.h>
  59          #include <readad.h>
  60          #include <timer.h>
  61          //#include "flash_config.h"
  62          //#include "compiler.h"
  63          //#include "flash_api.h"
  64          
  65          /*软件下载*/
  66          static unsigned int xdata nextSoftPktSn;                                //请求软件下载包的序号
  67          static unsigned int xdata preSoftChecksum = 0xFFFF;             //前次下载软件的校验和
  68          static unsigned int xdata softChecksum;                                 //整个软件的checksum值
  69          static unsigned int xdata softLen = 0;                                  //软件总长度
  70          //static unsigned char idata pktDataBuf[32];
  71          unsigned char code factry[8]={0xF0,0xD8,0x80,0xA8,0x5F,0xE0,0x87,0xC9}; 
  72          
  73          
  74          /*
  75          *********************************************************************************************************
  76          *                         数据包解码                                            
  77          *
  78          * Description: 对readXPktBuf中的数据进行解码，包括二字拆分，区分命令和数据，取得CRC值
  79          *
  80          * Arguments  : 无
  81          *
  82          * Returns    : 无
  83          *********************************************************************************************************
  84          */
  85          void execute_cmd() 
  86          {
  87   1              unsigned char resultCode = NO_ERR;              
  88   1              unsigned char downresult = NO_ERR;
  89   1              switch(RxBuf[5])
  90   1              {
  91   2                      case 0xDA:                                                                              //查询和设置工厂参数
  92   2                      {
  93   3                              execFctParamSet();      
  94   3                              break;
  95   3                  }
  96   2                      case 0xF0:                                                                              //RF模块射频（工厂）参数查询    
  97   2                      {
  98   3                              execRFParamQ();
  99   3                              break;
 100   3                      }
 101   2                      case 0xFD:                                                                              //软件下载确认或查询模块信息    
 102   2                      {
 103   3                              if(RxBuf[7]==0x01)
 104   3                              {
 105   4                                      if(RxBuf[8]==0)                                                         //下载取消
 106   4                                      {
 107   5                                              Data_len = 10;
 108   5                                      }
 109   4                                      else                                                                       //下载确认
 110   4                                      {
 111   5                                              downresult = endDwnldSoft();
 112   5                                              RxBuf[6] |= downresult;                                 //应答标志
 113   5                                              Data_len = 10;
 114   5                                      }
 115   4                              }
 116   3                              break;
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 3   

 117   3                      }
 118   2                      case 0xFE:                                                                              //软件下载                      
 119   2                      {
 120   3                              resultCode = execDwnldSoft();
 121   3                              RxBuf[1] = 9;                                                           //数据包长度     
 122   3                              RxBuf[4] = 7;
 123   3                              RxBuf[6] |= resultCode;                                         //应答标志
 124   3                              RxBuf[9] = (unsigned char)nextSoftPktSn;
 125   3                              RxBuf[10] = (unsigned char)(nextSoftPktSn>>8);
 126   3                              Data_len = 11;
 127   3                              break;
 128   3                      }
 129   2              
 130   2                      default:                                                                                //命令编号错
 131   2                      {
 132   3                              ack_flag = CMDID_ERR;   
 133   3                              break;
 134   3                      }
 135   2              }       
 136   1      }
 137          /*
 138          *********************************************************************************************************
 139          *                         定时查询告警信息                                              
 140          *
 141          * Description: 
 142          *
 143          * Arguments  : 无
 144          *
 145          * Returns    : 无
 146          *********************************************************************************************************
 147          */
 148          void updateAlmInfo() small
 149          {
 150   1              unsigned char i;
 151   1              PA_current = 0;
 152   1              OutputPwr = 0;
 153   1              re_Pwr =0;      
 154   1      //      InputPwr = 0;
 155   1              if(gRFSW==0)
 156   1              {
 157   2                      PLL_state = 0;                                                                  //射频开关关闭时锁频状态为正常
 158   2                      Lim_state = 0;                                                                  //射频开关关闭时限幅状态为正常
 159   2              }
 160   1              else
 161   1              { 
 162   2                      PLL_state = (LockYes ==0 ? TRUE : FALSE);               //检测失锁状态  
 163   2                      Lim_state = (LimYes ==0 ? FALSE : TRUE );               //检测限幅状态
 164   2              }
 165   1              LNA_state = (LnaFail==0 ? TRUE : FALSE);                        //检测LNA告警状态
 166   1              watchdog();
 167   1              for(i=0;i<5;i++)
 168   1              {
 169   2                      OutputPwr += readAD(2);                                                 //读输出功率AD值
 170   2                      re_Pwr += readAD(1);                                                    //读反射功率AD值
 171   2                      watchdog();
 172   2      //              InputPwr +=  readAD(8);                                                 //读输入功率AD值
 173   2                      PA_current += readAD(16);                                               //读出功放电流AD值      
 174   2              }
 175   1              PA_current /=5;
 176   1              OutputPwr /=5;
 177   1              re_Pwr /=5;     
 178   1      //      InputPwr /=5;   
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 4   

 179   1      
 180   1              if(auto_switchPA==1)                                                            //LM75的os引脚输出高电平，则关功放      
 181   1              {       
 182   2                      gPASW_auto = 0; 
 183   2              }
 184   1              else 
 185   1              {
 186   2                      gPASW_auto = gPASW;
 187   2              }
 188   1              
 189   1      }
 190          
 191          
 192          /*
 193          *********************************************************************************************************
 194          *                         工厂参数设置命令                                              
 195          *
 196          * Description: 标号分配为0x0ADA，对各个工厂参数进行设置，查询在另一命令中
 197          *
 198          * Arguments  : 无
 199          *
 200          * Returns    : 无
 201          *********************************************************************************************************
 202          */
 203          
 204          
 205          void execFctParamSet()
 206          {
 207   1              //unsigned long xdata tempval;
 208   1      
 209   1              unsigned char tempLen;                                                  //EEPROM字节数
 210   1              unsigned int param_addr;                                                        //参数对应的EEPROM地址
 211   1              unsigned int tmpInt;
 212   1              unsigned char bus;
 213   1              unsigned char temp[4];
 214   1      
 215   1              bus =  RxBuf[8];
 216   1              tempLen = RxBuf[12];                                                            //EEPROM字节数
 217   1              param_addr = RxBuf[10]; 
 218   1              param_addr += (RxBuf[11]<<8);                                           //参数对应的EEPROM地址
 219   1       
 220   1              if(RxBuf[7]==0)                                                                         //工厂参数查询
 221   1              {
 222   2                      readE2promStr(tempLen,param_addr,&RxBuf[13]);   
 223   2                      switch(param_addr)
 224   2                      {
 225   3                              case 0x0004:
 226   3                                      RxBuf[13] = gAtt2;
 227   3                                      break;
 228   3                              case 0x008C:
 229   3                                      RxBuf[13] =  (char)gPAIqact;
 230   3                                      RxBuf[14] =  (char)(gPAIqact>>8);
 231   3                                      break;
 232   3                              case 0x00A4:
 233   3                                      IRcvStr(0x90,0x03,temp,2);
 234   3                                      RxBuf[13] = temp[0];
 235   3                                      break;
 236   3                              case 0x00A5:
 237   3                                      IRcvStr(0x90,0x02,temp,2);
 238   3                                      RxBuf[13] = temp[0];
 239   3                                      break;
 240   3                              case 0x00D2:                                                                    //1字节，调试命令标志，0为正常状态，1为调试状态
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 5   

 241   3                                      RxBuf[13] = gtestflag;
 242   3                                      break;                                          
 243   3                      }                               
 244   2              }                                                                                                       //工厂参数设置
 245   1              else
 246   1              {
 247   2                      if (tempLen==2)
 248   2                      {
 249   3                              tmpInt = RxBuf[13];
 250   3                              tmpInt += (RxBuf[14]<<8);       
 251   3                      }
 252   2      /*              else if(tempLen==4)
 253   2                      {
 254   2                              tempval = RxBuf[13];
 255   2                              tempval += (RxBuf[14]<<8);
 256   2                              tempval += (RxBuf[15]<<16);     
 257   2                              tempval += (RxBuf[16]<<24);
 258   2                      } */
 259   2                      switch(param_addr)
 260   2                      {
 261   3                              case 0x0001:                                                                    //1字节，增益设定值
 262   3                                      if((RxBuf[13]<0)||(RxBuf[13]>31))
 263   3                                      {
 264   4                                              RxBuf[6] |= DATRANGE_ERR;       
 265   4                                      }
 266   3                                      break;
 267   3                              case 0x0002:                                                                    //1字节，增益调整值
 268   3                              case 0x0003:                                                                    //1字节，1＃衰减器
 269   3                              case 0x0004:                                                                    //1字节，2＃衰减器
 270   3                                      if((RxBuf[13]<0)||(RxBuf[13]>63))
 271   3                                      {
 272   4                                              RxBuf[6] |= DATRANGE_ERR;       
 273   4                                      }
 274   3                                      break;
 275   3                              /*case 0x0022:                                                                  //2字节，输出功率定标值
 276   3                              case 0x0026:                                                                    //2字节，发射功率定标值
 277   3                              case 0x002A:                                                                    //2字节，输入功率定标值 
 278   3                              case 0x0082：                                                                   //2字节，电流检测调整值
 279   3                                      break;
 280   3                              case 0x0024:                                                                    //2字节，输出功率检测斜率
 281   3                              case 0x0028:                                                                    //2字节，反射功率检测斜率
 282   3                              case 0x002C:                                                                    //2字节，输入功率检测斜率
 283   3                              case 0x0080:                                                                    //2字节，电流检测斜率
 284   3                              case 0x008C:                                                                    //2字节，偏压温补斜率
 285   3                                      break;  
 286   3                              case 0x0040:                                                                    //4字节，中心频率
 287   3                              case 0x004C：                                                                   //4字节，中频频率值
 288   3                              case 0x0054:                                                                    //4字节，参考频率
 289   3                                      break;
 290   3                              case 0x0048：                                                                   //2字节，中频调整值
 291   3                              case 0x004A：                                                                   //2字节，频率步进值
 292   3                                      break;
 293   3      
 294   3                         */
 295   3                              case 0x0020:                                                                    //2字节，功放限幅
 296   3                              case 0x0088:                                                                    //2字节,功放偏压值                      
 297   3                                      if( (tmpInt<0)||(tmpInt>1023) )
 298   3                                      {
 299   4                                              RxBuf[6] |= DATRANGE_ERR;       
 300   4                                      }
 301   3                                      break;
 302   3                              case 0x00A0:                                                                    //1字节，声表温补系数分子
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 6   

 303   3                              case 0x00A1:                                                                    //1字节，声表温补系数分母                       
 304   3                              case 0x00A2:                                                                    //1字节，增益温补系数分子
 305   3                              case 0x00A3:                                                                    //1字节，增益温补系数分母
 306   3                                      if((RxBuf[13]<0)||(RxBuf[13]>255))
 307   3                                      {
 308   4                                              RxBuf[6] |= DATRANGE_ERR;       
 309   4                                      }
 310   3                                      break;
 311   3                              case 0x00A4:                                                                    //1字节，功放保护温度下限
 312   3                              case 0x00A5:                                                                    //1字节，功放重起温度下限
 313   3                                      if((RxBuf[13]<0)||(RxBuf[13]>125))
 314   3                                      {
 315   4                                              RxBuf[6] |= DATRANGE_ERR;       
 316   4                                      }
 317   3                                      break;
 318   3                              case 0x00D2:                                                                    //1字节，调试状态
 319   3                                      if((RxBuf[13]<0)||(RxBuf[13]>2))                
 320   3                                      {
 321   4                                              RxBuf[6] |= DATRANGE_ERR;       
 322   4                                      }
 323   3                                      break;    
 324   3      
 325   3                              case 0x00D3:                                                                    //1字节，温补基准值
 326   3                                      if((RxBuf[13]<0)||(RxBuf[13]>16))
 327   3                                      {
 328   4                                              RxBuf[6] |= DATRANGE_ERR;       
 329   4                                      }
 330   3                                      break;
 331   3                              default:
 332   3                                      break;          
 333   3                      }
 334   2                      if(RxBuf[6]==0x0A)
 335   2                      {
 336   3                              writeE2promStr(tempLen,param_addr,&RxBuf[13]);                  
 337   3                              rfPramModified = TRUE;          
 338   3                              switch(param_addr)
 339   3                              {
 340   4                                      case 0x0001:                                                                    //1字节，增益设定值
 341   4                                              gAtteVal = RxBuf[13];
 342   4                                              writeAttenuator(bus,gAtteVal);
 343   4                                              break;
 344   4                                      case 0x0002:                                                                    //1字节，增益调整值
 345   4                                              gGainOffset =  RxBuf[13];
 346   4                                              writeAttenuator(bus,gAtteVal);                  
 347   4                                              break;
 348   4                                      case 0x0003:                                                                    //1字节，1＃衰减器
 349   4                                              gAtt1 = RxBuf[13];
 350   4                                              writeAtt1(gAtt1);
 351   4                                              break;
 352   4                                      case 0x0004:                                                                    //1字节，2＃衰减器
 353   4                                              gAtt2 = RxBuf[13];
 354   4                                              writeAtt2(gAtt2);
 355   4                                              break;
 356   4                                      case 0x0020:                                                                    //2字节，功放限幅
 357   4                                              gPALim =  tmpInt;
 358   4                                              writeDA1661(gPALim,'A');
 359   4                                              break;
 360   4                                      case 0x0040:                                                                    //4字节，中心频率
 361   4                                      case 0x0048:                                                                    //2字节，中频调整值
 362   4                                      case 0x004A:                                                                    //2字节，频率步进值
 363   4                                      case 0x004C:                                                                    //4字节，中频频率值
 364   4                                      case 0x0050:                                                                    //4字节，本振频率
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 7   

 365   4                                      case 0x0054:                                                                    //4字节，参考频率
 366   4                                      case 0x0058:                                                                    //4字节，PLLR寄存器
 367   4                                      case 0x005C:                                                                    //4字节，PLLN寄存器
 368   4                                      case 0x0060:                                                                    //4字节，PLLF寄存器
 369   4                                      case 0x00A0:                                                                    //1字节，声表温补系数分子
 370   4                                      case 0x00A1:                                                                    //1字节，声表温补系数分母                       
 371   4                                              writePLL();
 372   4                                              break;
 373   4                                      case 0x0088:                                                                    //2字节,功放偏压值                      
 374   4                                              gPAIq = tmpInt;
 375   4                                              //writeDA1661(gPAIq,'B');
 376   4                                              tempwritePAIq();                                                        //对功放偏压进行温度补偿
 377   4                                              break;
 378   4                                      case 0x008A:                                                                    //2字节，偏压温补斜率
 379   4                                              gPAIqCo = tmpInt;
 380   4                                              
 381   4                                              tempwritePAIq();                                                        //对功放偏压进行温度补偿
 382   4                                              break;                                  
 383   4                                      case 0x00A2:                                                                    //1字节，增益温补系数分子
 384   4                                      case 0x00A3:                                                                    //1字节，增益温补系数分母
 385   4                                              tempCompensate();
 386   4                                              break;
 387   4                                      case 0x00A4:                                                                    //2字节，功放保护温度下限
 388   4                                              gPAProtecttLim = RxBuf[13];
 389   4                                              writeLM75(0x03,gPAProtecttLim,3);       
 390   4                                              break;
 391   4                                      case 0x00A5:                                                                    //2字节，功放重起温度下限
 392   4                                              gPAResetLim = RxBuf[13];
 393   4                                              writeLM75(0x02,gPAResetLim,3);  
 394   4                                              break;
 395   4                                      case 0x00C0:                                                                    //1字节，射频模块编号
 396   4                                              gRF_No = RxBuf[13];     
 397   4                                              break;
 398   4                                      case 0x00C1:                                                                    //1字节，功放开关
 399   4                                              gPASW = RxBuf[13];
 400   4                                              switchPA(gPASW);
 401   4                                              break;
 402   4                                      case 0x00C2:                                                                    //1字节，射频开关
 403   4                                              gRFSW =  RxBuf[13];
 404   4                                              gPASW = RxBuf[13];
 405   4                                              switchRF(gRFSW);
 406   4                                              switchPA(gPASW);
 407   4                                              watchdog();
 408   4                                              writeE2promStr(1,EE_PASW,&RxBuf[13]);           //将功放开关写入eeprom中                
 409   4                                              if(gRFSW==1)
 410   4                                              {
 411   5                                                      InitRF();
 412   5                                              }                               
 413   4                                              break;
 414   4                                      case 0x00D0:                                                                    //2字节，调试温度
 415   4                                              gtestRfTemp = (int)tmpInt;
 416   4                                              break;
 417   4                                      case 0x00D2:                                                                    //1字节，调试命令标志，0为正常状态，1为调试状态
 418   4                                              gtestflag =  RxBuf[13]; 
 419   4                                              break;
 420   4                                       case 0x00D3:   
 421   4                                              if(RxBuf[13]>16)
 422   4                                              {
 423   5                                                      RxBuf[13] = 9;  
 424   5                                              } 
 425   4                                              gTempgain = RxBuf[13];
 426   4                                              break;                                  
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 8   

 427   4                                      default:
 428   4                                              break;                                                    
 429   4                              }
 430   3                      }
 431   2              }
 432   1              Data_len = RxBuf[1] + 2;          
 433   1      }
 434          /*
 435          *********************************************************************************************************
 436          *                         RF模块射频参数查询                                            
 437          *
 438          * Description: 标号分配为0x0AF0，对各个工厂参数进行一次性查询
 439          *
 440          * Arguments  : 无
 441          *
 442          * Returns    : 无
 443          *********************************************************************************************************
 444          */
 445          void execRFParamQ()
 446          {
 447   1              unsigned char i;        
 448   1              unsigned int CKS = 0;
 449   1      
 450   1              if(RxBuf[7]==0)                                                                         //定时数据查询
 451   1              {
 452   2                      RxBuf[1] = 21;                                                                  //数据包长度
 453   2                      RxBuf[4] = 19;                                                                  //监控对象的长度
 454   2                      
 455   2                      RxBuf[8] = LNA_state;
 456   2                      RxBuf[9] = PLL_state;
 457   2                      RxBuf[10] = Lim_state;
 458   2                      RxBuf[11] = gPASW_auto;
 459   2                      RxBuf[12] = gRFSW;
 460   2                      RxBuf[13] = (unsigned char)PA_current;                  //低位在前
 461   2                      RxBuf[14] = (unsigned char)(PA_current>>8);             //高位在后
 462   2                      RxBuf[15] = (unsigned char)OutputPwr;
 463   2                      RxBuf[16] = (unsigned char)(OutputPwr>>8);
 464   2                      RxBuf[17] = (unsigned char)re_Pwr;
 465   2                      RxBuf[18] = (unsigned char)(re_Pwr>>8);
 466   2                      //RxBuf[19] = (unsigned char)InputPwr;;
 467   2                      //RxBuf[20] = (unsigned char)(InputPwr>>8);
 468   2                      RxBuf[19] = 0x00;
 469   2                      RxBuf[20] = 0x00;
 470   2                      //readTemperatur();
 471   2                      RxBuf[21] = (char)gcurRfTemp;
 472   2                      RxBuf[22] = (char)(gcurRfTemp>>8);      
 473   2                      Data_len = 23;
 474   2              }
 475   1              else if(RxBuf[7]==1)                                                            //工厂参数查询数据包
 476   1              {               
 477   2                      RxBuf[1] = 101;                                                                 //数据包长度                                            
 478   2                      RxBuf[4] = 99;                                                                  //监控对象的长度                                                
 479   2                      readE2promStr(5,EE_AtteVal,&RxBuf[10]);                 //增益参数              
 480   2                      readE2promStr(15,EE_PALim,&RxBuf[15]);                  //功放参数              
 481   2                      watchdog();
 482   2                      readE2promStr(36,EE_CenFreq,&RxBuf[30]);                //频率参数                              
 483   2                      readE2promStr(14,EE_CurCo,&RxBuf[66]);                  //电流参数              
 484   2                      watchdog();
 485   2                      readE2promStr(6,EE_SAWFNumer,&RxBuf[80]);               //温度参数              
 486   2                      readE2promStr(3,EE_RF_No,&RxBuf[86]);                   //模块参数              
 487   2                      
 488   2                      RxBuf[13] = gAtt2;
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 9   

 489   2                      RxBuf[78] =  (char)gPAIqact;
 490   2                      RxBuf[79] =  (char)(gPAIqact>>8);
 491   2                      RxBuf[89] = Ver_Low;
 492   2                      RxBuf[90] = Ver_High;
 493   2                      RxBuf[91] = (unsigned char)all_checksum;
 494   2                      RxBuf[92] =     (unsigned char)(all_checksum >> 8);
 495   2                      readE2promStr(10,EE_MODULE_No,&RxBuf[93]);                      //模块参数              
 496   2                      watchdog();
 497   2                      for(i=0;i<93;i++)
 498   2                      {
 499   3                              CKS += RxBuf[10+i];
 500   3                      }       
 501   2                      watchdog();     
 502   2                      RxBuf[8] = (unsigned char)CKS;
 503   2                      RxBuf[9] = (unsigned char)(CKS>>8);
 504   2                      
 505   2              
 506   2                      Data_len = 103; 
 507   2              }               
 508   1      }
 509          /*
 510          *********************************************************************************************************
 511          *                         数据包编码                                            
 512          *
 513          * Description: 对包数据进行编码,ack包置于readXPktBuf中
 514          *                          本函数必须为可重入的
 515          *
 516          * Arguments  : X_PACKET指针，指向需要处理的包指针，未进行CRC校验
 517          *
 518          * Returns    : 无
 519          *********************************************************************************************************
 520          */
 521          void sendPkt()
 522          {
 523   1              unsigned char *tmpPtr;
 524   1              unsigned char calPktChecksum;
 525   1              unsigned char x;
 526   1              tmpPtr = TxBuf; 
 527   1              *tmpPtr++= 0x00;                                                                        //先发主机地址，固定为0x00                                                                              
 528   1              *tmpPtr++= 0x55;                                                                        //包起始标志
 529   1              *tmpPtr++= 0xAA;
 530   1              memcpy(tmpPtr,RxBuf,Data_len);                                          //整个包的数据长度，包括起始标志
 531   1              calDefcksum(tmpPtr,Data_len,&calPktChecksum);           //计算异或校验和
 532   1              tmpPtr += Data_len;
 533   1              *tmpPtr++= calPktChecksum;
 534   1              *tmpPtr++= 0x00;         //无用字节
 535   1              TB8 = 0x01;                                                                                     //第一个字节为地址字节，TB8必须为1
 536   1              Tx_ptr = 0;
 537   1              RDE = 1;
 538   1              for(x=0;x<0x80;x++)
 539   1              {
 540   2              }
 541   1              SBUF =  TxBuf[Tx_ptr];
 542   1              pack_valid = 0;
 543   1                                      
 544   1      }
 545          /*
 546          *********************************************************************************************************
 547          *                         软件下载成功或查询模块信息                                            
 548          *
 549          * Description: 标号分配为0x0AFD，软件下载完成要将程序从EEPROM中读出到flash中，并程序转移到0x0000执行
 550          *
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 10  

 551          * Arguments  : 无
 552          *
 553          * Returns    : 无
 554          *********************************************************************************************************
 555          */
 556          unsigned char endDwnldSoft()
 557          {       
 558   1              unsigned int checksum = 0;
 559   1              unsigned int count;
 560   1              unsigned int i,j;
 561   1              unsigned char leaveCnt;
 562   1              unsigned char err;
 563   1              unsigned int tmpInt;
 564   1              unsigned int x,y;
 565   1              
 566   1              count = 0x1D00 - softLen;
 567   1              leaveCnt = count % 32;                                                          //不足64字节的数目
 568   1              count = count / 32; 
 569   1              
 570   1              if( leaveCnt != 0)                                                                      //不满64字节
 571   1              {
 572   2                      XmtDat[1] =  (unsigned char)softLen ;
 573   2                      XmtDat[0] =  (unsigned char)(softLen>>8) ;
 574   2                      for(i=0;i<leaveCnt;i++)
 575   2                      {
 576   3                              XmtDat[2+i] = 0xFF;
 577   3                      }
 578   2                      watchdog();
 579   2                      err = ISendStrExt(0xA0,XmtDat,leaveCnt+2);
 580   2                      if( err == FALSE )
 581   2                      {
 582   3                              return OTHER_ERR;                                                       //E2PROM错
 583   3                      }
 584   2              }        
 585   1              for(j=0;j<count;j++)
 586   1              {
 587   2                      err = 0;                
 588   2                      for(x=0;x<0x05;x++)
 589   2                      {
 590   3                              for(y=0;y<0xFFFF;y++);
 591   3                      }                        
 592   2                      tmpInt = softLen + leaveCnt + j * 32;
 593   2                      XmtDat[1] = (unsigned char)tmpInt;
 594   2                      XmtDat[0] = (unsigned char)(tmpInt>>8);
 595   2      
 596   2                      for(i=0;i<32;i++)
 597   2                      {
 598   3                              XmtDat[2+i] = 0xFF;
 599   3                      }
 600   2                      watchdog();
 601   2                      err = ISendStrExt(0xA0,XmtDat,34);                      
 602   2                      if( err == FALSE )
 603   2                      {
 604   3                              return OTHER_ERR;                                                       //E2PROM错
 605   3                      }               
 606   2              }  
 607   1              WP = 1;                                                                                         //打开写保护，芯片只可读
 608   1              EA = 0;
 609   1      
 610   1              FMCON = 0x08;
 611   1              FMDATA = 0x96;                          //WE=1   打开flash写使能
 612   1              while((FMCON&0x0F)!=0);
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 11  

 613   1              
 614   1              FMCON = 0x67;
 615   1              FMDATA = 0x96;                          //CWP=0
 616   1              while((FMCON&0x0F)!=0);          
 617   1      
 618   1              FMADRL = 0x02;
 619   1              FMCON = 0x6C;
 620   1              FMDATA = 0x1D;                          //启动向量0x1E  
 621   1              while((FMCON&0x0F)!=0);
 622   1              
 623   1              FMADRL = 0x03;                          //状态字节
 624   1              FMCON = 0x6C;                           //访问由FMADRL 寻址的用户配置信息
 625   1              FMDATA = 0x61;                          //CWP=1 AWP=1  BSB=1    
 626   1              while((FMCON&0x0F)!=0);
 627   1              
 628   1              while(1);
 629   1              //AUXR1 = 8;            
 630   1      
 631   1              return TRUE;            
 632   1      }
 633          /*
 634          *********************************************************************************************************
 635          *                         RF模块软件下载                                                
 636          *
 637          * Description: 标号分配为0x0AFE，对射频模块的程序进行在系统升级
 638          *
 639          * Arguments  : 无
 640          *
 641          * Returns    : 无
 642          *********************************************************************************************************
 643          */
 644          unsigned char execDwnldSoft()
 645          {
 646   1              unsigned char xdata *tmpPtr = RxBuf;                                    //指向源数据的指针
 647   1              unsigned int  idata curSoftPktSn;                                               //当前软件包序号，16位数的临时变量
 648   1              unsigned char idata err;        
 649   1              unsigned int  idata total_len;
 650   1              unsigned char  idata i;
 651   1              unsigned int  idata datadrs;
 652   1              
 653   1              tmpPtr += 7;                                                                                    //取到数据的开头，包序号
 654   1              swapBytes(tmpPtr, (unsigned char *)&curSoftPktSn,2);    //取到包序号置于curSoftPktSn中  
 655   1              tmpPtr += 2;                                                                                    //指针指向数据长度
 656   1              swapBytes(tmpPtr, (unsigned char *)&total_len,2);               //取到数据长度  
 657   1              tmpPtr += 2;                                                                                    //指向数据部分
 658   1              if(curSoftPktSn == 0)                                                                   //第一个包
 659   1              {
 660   2                      if( total_len != 0x1C )                                                         //取得数据长度并指向起始地址
 661   2                      {                                                                                                                                                                        
 662   3                              return OTHER_ERR;                                                               //其他错误
 663   3                      }
 664   2                      tmpPtr += 0x18;                                                                         //指针指向文件CHECKSUM字节
 665   2                      swapBytes(tmpPtr, (unsigned char *)&softChecksum,2);//取得chechsum，保存于softChecksum
 666   2                      nextSoftPktSn = 1;
 667   2                      softDownLoad = DOING;
 668   2                      WP = 0;                                                                                         //关闭写保护，芯片可读可写
 669   2                      softLen = 0;
 670   2              }
 671   1              else                                                                                                    //非第一包
 672   1              {       
 673   2                      //dataLen = *tmpPtr++;
 674   2                      if(curSoftPktSn != nextSoftPktSn)                                       //校验包序号            
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 12  

 675   2                      {
 676   3                              return OTHER_ERR;                                                               //包序号错
 677   3                      }
 678   2                      if(total_len>32)
 679   2                      {
 680   3                              return OTHER_ERR;                                                               //超出一页写数据范围,一页写32个字节     
 681   3                      } 
 682   2                      datadrs = curSoftPktSn - 1;
 683   2                      datadrs = datadrs * 32;
 684   2                      XmtDat[1] =  (unsigned char)datadrs;
 685   2                      XmtDat[0] =  (unsigned char)(datadrs>>8);
 686   2                      for(i=0;i<total_len;i++)
 687   2                      {
 688   3                              XmtDat[2+i] = *(tmpPtr+i);
 689   3                      }
 690   2                      watchdog();
 691   2                      err = ISendStrExt(0xA0,XmtDat,total_len+2);
 692   2                      watchdog();
 693   2                      if( err == FALSE )
 694   2                      {
 695   3                              return OTHER_ERR;                                                               //E2PROM错
 696   3                      }               
 697   2                      softLen += total_len;                                                           //计算软件总长
 698   2                      
 699   2                      if(curSoftPktSn==3)
 700   2                      {
 701   3                              for( i = 0; i < 8; i++ )
 702   3                              {
 703   4                                      if(RxBuf[11+i]!= factry[i])
 704   4                                      {
 705   5                                              WP = 1;
 706   5                                              return OTHER_ERR;                                                               //E2PROM错      
 707   5                                      }
 708   4                              } 
 709   3                      }  
 710   2                      nextSoftPktSn++;
 711   2              }       
 712   1              return NO_ERR;                                                          //其他错误
 713   1      }
 714          /*计算异或校验和*/
 715          void calDefcksum(unsigned char *ptr, unsigned int len, unsigned char *checksum) small
 716          {
 717   1              unsigned char xdata tmpChecksum = 0;
 718   1      
 719   1              while(len--)
 720   1              {
 721   2                      tmpChecksum ^= *ptr++;
 722   2              }
 723   1              *checksum = tmpChecksum;  
 724   1      }
 725          /*
 726          *********************************************************************************************************
 727          *                         字节顺序交换
 728          *
 729          * Description: 字节流顺序交换
 730          *
 731          * Arguments  : 
 732          *                          result       指针，指向处理目标
 733          *                          src      指针，指向需要处理的字符串
 734          *
 735          * Returns    : 无
 736          *********************************************************************************************************
C51 COMPILER V7.06   PACKET                                                                03/30/2006 11:34:47 PAGE 13  

 737          */
 738          void swapBytes(unsigned char *src, unsigned char *result,unsigned char num)
 739          {
 740   1              unsigned char i;
 741   1              src += (num-1);
 742   1              for(i=0;i<num;i++)
 743   1              {
 744   2                      *result++ = *src--; 
 745   2              }
 746   1      }
 747          void delay(unsigned char time)
 748          {
 749   1              unsigned char x;
 750   1              unsigned int y;
 751   1              for(x=0;x<time;x++)
 752   1              {
 753   2                      watchdog();
 754   2                      for(y=0;y<0xFFFF;y++);
 755   2              }
 756   1      }
 757          
 758          void watchdog() 
 759          {
 760   1              EA = 0;                         //关闭中断 
 761   1              WFEED1 = 0xA5;          //执行清零第一部分 
 762   1              WFEED2 = 0x5A;          //执行清零第二部分 
 763   1              EA = 1;                         //开中断
 764   1                                      
 765   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2520    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      48
   IDATA SIZE       =   ----       8
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
