C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE BRO20W_PACKET
OBJECT MODULE PLACED IN .\OUTPUT\bro20W_packet.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE APP\bro20W_packet.c BROWSE INCDIR(.\APP;.\drive;.\LPC900) DEBUG OBJECTEXTEN
                    -D PRINT(.\list\bro20W_packet.lst) OBJECT(.\OUTPUT\bro20W_packet.obj)

stmt level    source

   1          /**-------------文件信息--------------------------------------------------------------------------------
   2          **文   件   名: packet.c
   3          **创   建   人: 程莺红
   4          **修   改   人: 
   5          **最后修改日期: 2006年3月31日
   6          **最 新 版  本: V1.2
   7          **描        述: 解析串口命令，并组织回复包，发送包
   8          **
   9          **--------------历史版本信息----------------------------------------------------------------------------
  10          ** 创建人: 程莺红 
  11          ** 版  本: V1.2
  12          ** 日　期: 2006年3月31日
  13          ** 描　述: 原始版本
  14          **
  15          **--------------历史版本信息----------------------------------------------------------------------------
  16          ** 创建人: 程莺红 
  17          ** 版  本: V1.3
  18          ** 日　期: 2006年4月24日
  19          ** 描　述: gatt1该为实时值
  20          **
  21          ********************************************************************************************************/
  22          
  23          #include <reg938.h>
  24          #include <stdio.h>
  25          #include <string.h>       
  26          #include <I2C.h>
  27          #include <SPI.h>
  28          #include <cpu.h>
  29          #include <serial.h>
  30          #include <task.h>
  31          #include <packet.h>
  32          #include <bro20W_RFparam.h>
  33          #include <bro20W_RFcontrol.h>
  34          #include <e2prom.h>
  35          #include <readad.h>
  36          #include <timer.h>
  37          //#include "flash_config.h"
  38          //#include "compiler.h"
  39          //#include "flash_api.h"
  40          
  41          /*软件下载*/
  42          static unsigned int xdata nextSoftPktSn;                                //请求软件下载包的序号
  43          static unsigned int xdata preSoftChecksum = 0xFFFF;             //前次下载软件的校验和
  44          static unsigned int xdata softChecksum;                                 //整个软件的checksum值
  45          static unsigned int xdata softLen = 0;                                  //软件总长度
  46          //static unsigned char idata pktDataBuf[32];
  47          unsigned char code factry[8]={0xF0,0xD8,0x80,0xA8,0x5F,0xE0,0x87,0xC9}; 
  48          
  49          
  50          /*
  51          *********************************************************************************************************
  52          *                         数据包解码                                            
  53          *
  54          * Description: 对readXPktBuf中的数据进行解码，包括二字拆分，区分命令和数据，取得CRC值
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 2   

  55          *
  56          * Arguments  : 无
  57          *
  58          * Returns    : 无
  59          *********************************************************************************************************
  60          */
  61          void execute_cmd() 
  62          {
  63   1              unsigned char resultCode = NO_ERR;              
  64   1              unsigned char downresult = NO_ERR;
  65   1              switch(RxBuf[5])
  66   1              {
  67   2                      case 0xDA:                                                                              //查询和设置工厂参数
  68   2                      {
  69   3                              execFctParamSet();      
  70   3                              break;
  71   3                  }
  72   2                      case 0xF0:                                                                              //RF模块射频（工厂）参数查询    
  73   2                      {
  74   3                              execRFParamQ();
  75   3                              break;
  76   3                      }
  77   2                      case 0xFD:                                                                              //软件下载确认或查询模块信息    
  78   2                      {
  79   3                              if(RxBuf[7]==0x01)
  80   3                              {
  81   4                                      if(RxBuf[8]==0)                                                         //下载取消
  82   4                                      {
  83   5                                              Data_len = 10;
  84   5                                      }
  85   4                                      else                                                                       //下载确认
  86   4                                      {
  87   5                                              downresult = endDwnldSoft();
  88   5                                              RxBuf[6] |= downresult;                                 //应答标志
  89   5                                              Data_len = 10;
  90   5                                      }
  91   4                              }
  92   3                              break;
  93   3                      }
  94   2                      case 0xFE:                                                                              //软件下载                      
  95   2                      {
  96   3                              resultCode = execDwnldSoft();
  97   3                              RxBuf[1] = 9;                                                           //数据包长度     
  98   3                              RxBuf[4] = 7;
  99   3                              RxBuf[6] |= resultCode;                                         //应答标志
 100   3                              RxBuf[9] = (unsigned char)nextSoftPktSn;
 101   3                              RxBuf[10] = (unsigned char)(nextSoftPktSn>>8);
 102   3                              Data_len = 11;
 103   3                              break;
 104   3                      }
 105   2              
 106   2                      default:                                                                                //命令编号错
 107   2                      {
 108   3                              ack_flag = CMDID_ERR;   
 109   3                              break;
 110   3                      }
 111   2              }       
 112   1      }
 113          /*
 114          *********************************************************************************************************
 115          *                         定时查询告警信息                                              
 116          *
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 3   

 117          * Description: 
 118          *
 119          * Arguments  : 无
 120          *
 121          * Returns    : 无
 122          *********************************************************************************************************
 123          */
 124          void updateAlmInfo() small
 125          {
 126   1              unsigned char i;
 127   1              PA_current = 0;
 128   1              OutputPwr = 0;
 129   1              re_Pwr =0;      
 130   1      //      InputPwr = 0;
 131   1              if(gRFSW==0)
 132   1              {
 133   2                      PLL_state = 0;                                                                  //射频开关关闭时锁频状态为正常
 134   2                      Lim_state = 0;                                                                  //射频开关关闭时限幅状态为正常
 135   2              }
 136   1              else
 137   1              { 
 138   2                      PLL_state = (LockYes ==0 ? TRUE : FALSE);               //检测失锁状态  
 139   2                      Lim_state = (LimYes ==0 ? FALSE : TRUE );               //检测限幅状态
 140   2              }
 141   1              LNA_state = (LnaFail==0 ? TRUE : FALSE);                        //检测LNA告警状态
 142   1              watchdog();
 143   1              for(i=0;i<5;i++)
 144   1              {
 145   2                      OutputPwr += readAD(2);                                                 //读输出功率AD值
 146   2                      re_Pwr += readAD(1);                                                    //读反射功率AD值
 147   2                      watchdog();
 148   2      //              InputPwr +=  readAD(8);                                                 //读输入功率AD值
 149   2                      PA_current += readAD(16);                                               //读出功放电流AD值      
 150   2              }
 151   1              PA_current /=5;
 152   1              OutputPwr /=5;
 153   1              re_Pwr /=5;     
 154   1      //      InputPwr /=5;   
 155   1      
 156   1              if(auto_switchPA==1)                                                            //LM75的os引脚输出高电平，则关功放      
 157   1              {       
 158   2                      gPASW_auto = 0; 
 159   2              }
 160   1              else 
 161   1              {
 162   2                      gPASW_auto = gPASW;
 163   2              }
 164   1              
 165   1      }
 166          
 167          
 168          /*
 169          *********************************************************************************************************
 170          *                         工厂参数设置命令                                              
 171          *
 172          * Description: 标号分配为0x0ADA，对各个工厂参数进行设置，查询在另一命令中
 173          *
 174          * Arguments  : 无
 175          *
 176          * Returns    : 无
 177          *********************************************************************************************************
 178          */
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 4   

 179          
 180          
 181          void execFctParamSet()
 182          {
 183   1              //unsigned long xdata tempval;
 184   1      
 185   1              unsigned char tempLen;                                                  //EEPROM字节数
 186   1              unsigned int param_addr;                                                        //参数对应的EEPROM地址
 187   1              unsigned int tmpInt;
 188   1              unsigned char bus;
 189   1              unsigned char temp[4];
 190   1      
 191   1              bus =  RxBuf[8];
 192   1              tempLen = RxBuf[12];                                                            //EEPROM字节数
 193   1              param_addr = RxBuf[10]; 
 194   1              param_addr += (RxBuf[11]<<8);                                           //参数对应的EEPROM地址
 195   1       
 196   1              if(RxBuf[7]==0)                                                                         //工厂参数查询
 197   1              {
 198   2                      readE2promStr(tempLen,param_addr,&RxBuf[13]);   
 199   2                      switch(param_addr)
 200   2                      {
 201   3                              case 0x0003:
 202   3                                      RxBuf[13] = gAtt1;
 203   3                                      break;
 204   3                              case 0x0004:
 205   3                                      RxBuf[13] = gAtt2;
 206   3                                      break;
 207   3                              case 0x008C:
 208   3                                      RxBuf[13] =  (char)gPAIqact;
 209   3                                      RxBuf[14] =  (char)(gPAIqact>>8);
 210   3                                      break;
 211   3                              case 0x00A4:
 212   3                                      IRcvStr(0x90,0x03,temp,2);
 213   3                                      RxBuf[13] = temp[0];
 214   3                                      break;
 215   3                              case 0x00A5:
 216   3                                      IRcvStr(0x90,0x02,temp,2);
 217   3                                      RxBuf[13] = temp[0];
 218   3                                      break;
 219   3                              case 0x00D2:                                                                    //1字节，调试命令标志，0为正常状态，1为调试状态
 220   3                                      RxBuf[13] = gtestflag;
 221   3                                      break;                                          
 222   3                      }                               
 223   2              }                                                                                                       //工厂参数设置
 224   1              else
 225   1              {
 226   2                      if (tempLen==2)
 227   2                      {
 228   3                              tmpInt = RxBuf[13];
 229   3                              tmpInt += (RxBuf[14]<<8);       
 230   3                      }
 231   2      /*              else if(tempLen==4)
 232   2                      {
 233   2                              tempval = RxBuf[13];
 234   2                              tempval += (RxBuf[14]<<8);
 235   2                              tempval += (RxBuf[15]<<16);     
 236   2                              tempval += (RxBuf[16]<<24);
 237   2                      } */
 238   2                      switch(param_addr)
 239   2                      {
 240   3                              case 0x0001:                                                                    //1字节，增益设定值
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 5   

 241   3                                      if((RxBuf[13]<0)||(RxBuf[13]>31))
 242   3                                      {
 243   4                                              RxBuf[6] |= DATRANGE_ERR;       
 244   4                                      }
 245   3                                      break;
 246   3                              case 0x0002:                                                                    //1字节，增益调整值
 247   3                              case 0x0003:                                                                    //1字节，1＃衰减器
 248   3                              case 0x0004:                                                                    //1字节，2＃衰减器
 249   3                                      if((RxBuf[13]<0)||(RxBuf[13]>63))
 250   3                                      {
 251   4                                              RxBuf[6] |= DATRANGE_ERR;       
 252   4                                      }
 253   3                                      break;
 254   3                              /*case 0x0022:                                                                  //2字节，输出功率定标值
 255   3                              case 0x0026:                                                                    //2字节，发射功率定标值
 256   3                              case 0x002A:                                                                    //2字节，输入功率定标值 
 257   3                              case 0x0082：                                                                   //2字节，电流检测调整值
 258   3                                      break;
 259   3                              case 0x0024:                                                                    //2字节，输出功率检测斜率
 260   3                              case 0x0028:                                                                    //2字节，反射功率检测斜率
 261   3                              case 0x002C:                                                                    //2字节，输入功率检测斜率
 262   3                              case 0x0080:                                                                    //2字节，电流检测斜率
 263   3                              case 0x008C:                                                                    //2字节，偏压温补斜率
 264   3                                      break;  
 265   3                              case 0x0040:                                                                    //4字节，中心频率
 266   3                              case 0x004C：                                                                   //4字节，中频频率值
 267   3                              case 0x0054:                                                                    //4字节，参考频率
 268   3                                      break;
 269   3                              case 0x0048：                                                                   //2字节，中频调整值
 270   3                              case 0x004A：                                                                   //2字节，频率步进值
 271   3                                      break;
 272   3      
 273   3                         */
 274   3                              case 0x0020:                                                                    //2字节，功放限幅
 275   3                              case 0x0088:                                                                    //2字节,功放偏压值                      
 276   3                                      if( (tmpInt<0)||(tmpInt>1023) )
 277   3                                      {
 278   4                                              RxBuf[6] |= DATRANGE_ERR;       
 279   4                                      }
 280   3                                      break;
 281   3                              case 0x00A0:                                                                    //1字节，声表温补系数分子
 282   3                              case 0x00A1:                                                                    //1字节，声表温补系数分母                       
 283   3                              case 0x00A2:                                                                    //1字节，增益温补系数分子
 284   3                              case 0x00A3:                                                                    //1字节，增益温补系数分母
 285   3                                      if((RxBuf[13]<0)||(RxBuf[13]>255))
 286   3                                      {
 287   4                                              RxBuf[6] |= DATRANGE_ERR;       
 288   4                                      }
 289   3                                      break;
 290   3                              case 0x00A4:                                                                    //1字节，功放保护温度下限
 291   3                              case 0x00A5:                                                                    //1字节，功放重起温度下限
 292   3                                      if((RxBuf[13]<0)||(RxBuf[13]>125))
 293   3                                      {
 294   4                                              RxBuf[6] |= DATRANGE_ERR;       
 295   4                                      }
 296   3                                      break;
 297   3                              case 0x00D2:                                                                    //1字节，调试状态
 298   3                                      if((RxBuf[13]<0)||(RxBuf[13]>2))                
 299   3                                      {
 300   4                                              RxBuf[6] |= DATRANGE_ERR;       
 301   4                                      }
 302   3                                      break;    
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 6   

 303   3      
 304   3                              case 0x00D3:                                                                    //1字节，温补基准值
 305   3                                      if((RxBuf[13]<0)||(RxBuf[13]>16))
 306   3                                      {
 307   4                                              RxBuf[6] |= DATRANGE_ERR;       
 308   4                                      }
 309   3                                      break;
 310   3                              default:
 311   3                                      break;          
 312   3                      }
 313   2                      if(RxBuf[6]==0x0A)
 314   2                      {
 315   3                              writeE2promStr(tempLen,param_addr,&RxBuf[13]);                  
 316   3                              rfPramModified = TRUE;          
 317   3                              switch(param_addr)
 318   3                              {
 319   4                                      case 0x0001:                                                                    //1字节，增益设定值
 320   4                                              gAtteVal = RxBuf[13];
 321   4                                              writeAttenuator(bus,gAtteVal);
 322   4                                              break;
 323   4                                      case 0x0002:                                                                    //1字节，增益调整值
 324   4                                              gGainOffset =  RxBuf[13];
 325   4                                              writeAttenuator(bus,gAtteVal);                  
 326   4                                              break;
 327   4                                      case 0x0003:                                                                    //1字节，1＃衰减器
 328   4                                              gAtt1 = RxBuf[13];
 329   4                                              writeAtt1(gAtt1);
 330   4                                              break;
 331   4                                      case 0x0004:                                                                    //1字节，2＃衰减器
 332   4                                              gAtt2 = RxBuf[13];
 333   4                                              writeAtt2(gAtt2);
 334   4                                              break;
 335   4                                      case 0x0020:                                                                    //2字节，功放限幅
 336   4                                              gPALim =  tmpInt;
 337   4                                              writeDA1661(gPALim,'A');
 338   4                                              break;
 339   4                                      case 0x0040:                                                                    //4字节，中心频率
 340   4                                      case 0x0048:                                                                    //2字节，中频调整值
 341   4                                      case 0x004A:                                                                    //2字节，频率步进值
 342   4                                      case 0x004C:                                                                    //4字节，中频频率值
 343   4                                      case 0x0050:                                                                    //4字节，本振频率
 344   4                                      case 0x0054:                                                                    //4字节，参考频率
 345   4                                      case 0x0058:                                                                    //4字节，PLLR寄存器
 346   4                                      case 0x005C:                                                                    //4字节，PLLN寄存器
 347   4                                      case 0x0060:                                                                    //4字节，PLLF寄存器
 348   4                                      case 0x00A0:                                                                    //1字节，声表温补系数分子
 349   4                                      case 0x00A1:                                                                    //1字节，声表温补系数分母                       
 350   4                                              writePLL();
 351   4                                              break;
 352   4                                      case 0x0088:                                                                    //2字节,功放偏压值                      
 353   4                                              gPAIq = tmpInt;
 354   4                                              //writeDA1661(gPAIq,'B');
 355   4                                              tempwritePAIq();                                                        //对功放偏压进行温度补偿
 356   4                                              break;
 357   4                                      case 0x008A:                                                                    //2字节，偏压温补斜率
 358   4                                              gPAIqCo = tmpInt;
 359   4                                              
 360   4                                              tempwritePAIq();                                                        //对功放偏压进行温度补偿
 361   4                                              break;                                  
 362   4                                      case 0x00A2:                                                                    //1字节，增益温补系数分子
 363   4                                      case 0x00A3:                                                                    //1字节，增益温补系数分母
 364   4                                              tempCompensate();
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 7   

 365   4                                              break;
 366   4                                      case 0x00A4:                                                                    //2字节，功放保护温度下限
 367   4                                              gPAProtecttLim = RxBuf[13];
 368   4                                              writeLM75(0x03,gPAProtecttLim,3);       
 369   4                                              break;
 370   4                                      case 0x00A5:                                                                    //2字节，功放重起温度下限
 371   4                                              gPAResetLim = RxBuf[13];
 372   4                                              writeLM75(0x02,gPAResetLim,3);  
 373   4                                              break;
 374   4                                      case 0x00C0:                                                                    //1字节，射频模块编号
 375   4                                              gRF_No = RxBuf[13];     
 376   4                                              break;
 377   4                                      case 0x00C1:                                                                    //1字节，功放开关
 378   4                                              gPASW = RxBuf[13];
 379   4                                              switchPA(gPASW);
 380   4                                              break;
 381   4                                      case 0x00C2:                                                                    //1字节，射频开关
 382   4                                              gRFSW =  RxBuf[13];
 383   4                                              gPASW = RxBuf[13];
 384   4                                              switchRF(gRFSW);
 385   4                                              switchPA(gPASW);
 386   4                                              watchdog();
 387   4                                              writeE2promStr(1,EE_PASW,&RxBuf[13]);           //将功放开关写入eeprom中                
 388   4                                              if(gRFSW==1)
 389   4                                              {
 390   5                                                      InitRF();
 391   5                                              }                               
 392   4                                              break;
 393   4                                      case 0x00D0:                                                                    //2字节，调试温度
 394   4                                              gtestRfTemp = (int)tmpInt;
 395   4                                              break;
 396   4                                      case 0x00D2:                                                                    //1字节，调试命令标志，0为正常状态，1为调试状态
 397   4                                              gtestflag =  RxBuf[13]; 
 398   4                                              break;
 399   4                                       case 0x00D3:   
 400   4                                              if(RxBuf[13]>16)
 401   4                                              {
 402   5                                                      RxBuf[13] = 9;  
 403   5                                              } 
 404   4                                              gTempgain = RxBuf[13];
 405   4                                              break;                                  
 406   4                                      default:
 407   4                                              break;                                                    
 408   4                              }
 409   3                      }
 410   2              }
 411   1              Data_len = RxBuf[1] + 2;          
 412   1      }
 413          /*
 414          *********************************************************************************************************
 415          *                         RF模块射频参数查询                                            
 416          *
 417          * Description: 标号分配为0x0AF0，对各个工厂参数进行一次性查询
 418          *
 419          * Arguments  : 无
 420          *
 421          * Returns    : 无
 422          *********************************************************************************************************
 423          */
 424          void execRFParamQ()
 425          {
 426   1              unsigned char i;        
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 8   

 427   1              unsigned int CKS = 0;
 428   1      
 429   1              if(RxBuf[7]==0)                                                                         //定时数据查询
 430   1              {
 431   2                      RxBuf[1] = 21;                                                                  //数据包长度
 432   2                      RxBuf[4] = 19;                                                                  //监控对象的长度
 433   2                      
 434   2                      RxBuf[8] = LNA_state;
 435   2                      RxBuf[9] = PLL_state;
 436   2                      RxBuf[10] = Lim_state;
 437   2                      RxBuf[11] = gPASW_auto;
 438   2                      RxBuf[12] = gRFSW;
 439   2                      RxBuf[13] = (unsigned char)PA_current;                  //低位在前
 440   2                      RxBuf[14] = (unsigned char)(PA_current>>8);             //高位在后
 441   2                      RxBuf[15] = (unsigned char)OutputPwr;
 442   2                      RxBuf[16] = (unsigned char)(OutputPwr>>8);
 443   2                      RxBuf[17] = (unsigned char)re_Pwr;
 444   2                      RxBuf[18] = (unsigned char)(re_Pwr>>8);
 445   2                      //RxBuf[19] = (unsigned char)InputPwr;;
 446   2                      //RxBuf[20] = (unsigned char)(InputPwr>>8);
 447   2                      RxBuf[19] = 0x00;
 448   2                      RxBuf[20] = 0x00;
 449   2                      //readTemperatur();
 450   2                      RxBuf[21] = (char)gcurRfTemp;
 451   2                      RxBuf[22] = (char)(gcurRfTemp>>8);      
 452   2                      Data_len = 23;
 453   2              }
 454   1              else if(RxBuf[7]==1)                                                            //工厂参数查询数据包
 455   1              {               
 456   2                      RxBuf[1] = 101;                                                                 //数据包长度                                            
 457   2                      RxBuf[4] = 99;                                                                  //监控对象的长度                                                
 458   2                      readE2promStr(5,EE_AtteVal,&RxBuf[10]);                 //增益参数              
 459   2                      readE2promStr(15,EE_PALim,&RxBuf[15]);                  //功放参数              
 460   2                      watchdog();
 461   2                      readE2promStr(36,EE_CenFreq,&RxBuf[30]);                //频率参数                              
 462   2                      readE2promStr(14,EE_CurCo,&RxBuf[66]);                  //电流参数              
 463   2                      watchdog();
 464   2                      readE2promStr(6,EE_SAWFNumer,&RxBuf[80]);               //温度参数              
 465   2                      readE2promStr(3,EE_RF_No,&RxBuf[86]);                   //模块参数              
 466   2                      
 467   2                      RxBuf[12] = gAtt1;
 468   2                      RxBuf[13] = gAtt2;
 469   2                      RxBuf[78] =  (char)gPAIqact;
 470   2                      RxBuf[79] =  (char)(gPAIqact>>8);
 471   2                      RxBuf[89] = Ver_Low;
 472   2                      RxBuf[90] = Ver_High;
 473   2                      RxBuf[91] = (unsigned char)all_checksum;
 474   2                      RxBuf[92] =     (unsigned char)(all_checksum >> 8);
 475   2                      readE2promStr(10,EE_MODULE_No,&RxBuf[93]);                      //模块参数              
 476   2                      watchdog();
 477   2                      for(i=0;i<93;i++)
 478   2                      {
 479   3                              CKS += RxBuf[10+i];
 480   3                      }       
 481   2                      watchdog();     
 482   2                      RxBuf[8] = (unsigned char)CKS;
 483   2                      RxBuf[9] = (unsigned char)(CKS>>8);
 484   2                      
 485   2              
 486   2                      Data_len = 103; 
 487   2              }               
 488   1      }
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 9   

 489          /*
 490          *********************************************************************************************************
 491          *                         数据包编码                                            
 492          *
 493          * Description: 对包数据进行编码,ack包置于readXPktBuf中
 494          *                          本函数必须为可重入的
 495          *
 496          * Arguments  : X_PACKET指针，指向需要处理的包指针，未进行CRC校验
 497          *
 498          * Returns    : 无
 499          *********************************************************************************************************
 500          */
 501          void sendPkt()
 502          {
 503   1              unsigned char *tmpPtr;
 504   1              unsigned char calPktChecksum;
 505   1              unsigned char x;
 506   1              tmpPtr = TxBuf; 
 507   1              *tmpPtr++= 0x00;                                                                        //先发主机地址，固定为0x00                                                                              
 508   1              *tmpPtr++= 0x55;                                                                        //包起始标志
 509   1              *tmpPtr++= 0xAA;
 510   1              memcpy(tmpPtr,RxBuf,Data_len);                                          //整个包的数据长度，包括起始标志
 511   1              calDefcksum(tmpPtr,Data_len,&calPktChecksum);           //计算异或校验和
 512   1              tmpPtr += Data_len;
 513   1              *tmpPtr++= calPktChecksum;
 514   1              *tmpPtr++= 0x00;         //无用字节
 515   1              TB8 = 0x01;                                                                                     //第一个字节为地址字节，TB8必须为1
 516   1              Tx_ptr = 0;
 517   1              RDE = 1;
 518   1              for(x=0;x<0x80;x++)
 519   1              {
 520   2              }
 521   1              SBUF =  TxBuf[Tx_ptr];
 522   1              pack_valid = 0;
 523   1                                      
 524   1      }
 525          /*
 526          *********************************************************************************************************
 527          *                         软件下载成功或查询模块信息                                            
 528          *
 529          * Description: 标号分配为0x0AFD，软件下载完成要将程序从EEPROM中读出到flash中，并程序转移到0x0000执行
 530          *
 531          * Arguments  : 无
 532          *
 533          * Returns    : 无
 534          *********************************************************************************************************
 535          */
 536          unsigned char endDwnldSoft()
 537          {       
 538   1              unsigned int checksum = 0;
 539   1              unsigned int count;
 540   1              unsigned int i,j;
 541   1              unsigned char leaveCnt;
 542   1              unsigned char err;
 543   1              unsigned int tmpInt;
 544   1              unsigned int x,y;
 545   1              
 546   1              count = 0x1D00 - softLen;
 547   1              leaveCnt = count % 32;                                                          //不足64字节的数目
 548   1              count = count / 32; 
 549   1              
 550   1              if( leaveCnt != 0)                                                                      //不满64字节
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 10  

 551   1              {
 552   2                      XmtDat[1] =  (unsigned char)softLen ;
 553   2                      XmtDat[0] =  (unsigned char)(softLen>>8) ;
 554   2                      for(i=0;i<leaveCnt;i++)
 555   2                      {
 556   3                              XmtDat[2+i] = 0xFF;
 557   3                      }
 558   2                      watchdog();
 559   2                      err = ISendStrExt(0xA0,XmtDat,leaveCnt+2);
 560   2                      if( err == FALSE )
 561   2                      {
 562   3                              return OTHER_ERR;                                                       //E2PROM错
 563   3                      }
 564   2              }        
 565   1              for(j=0;j<count;j++)
 566   1              {
 567   2                      err = 0;                
 568   2                      for(x=0;x<0x05;x++)
 569   2                      {
 570   3                              for(y=0;y<0xFFFF;y++);
 571   3                      }                        
 572   2                      tmpInt = softLen + leaveCnt + j * 32;
 573   2                      XmtDat[1] = (unsigned char)tmpInt;
 574   2                      XmtDat[0] = (unsigned char)(tmpInt>>8);
 575   2      
 576   2                      for(i=0;i<32;i++)
 577   2                      {
 578   3                              XmtDat[2+i] = 0xFF;
 579   3                      }
 580   2                      watchdog();
 581   2                      err = ISendStrExt(0xA0,XmtDat,34);                      
 582   2                      if( err == FALSE )
 583   2                      {
 584   3                              return OTHER_ERR;                                                       //E2PROM错
 585   3                      }               
 586   2              }  
 587   1              WP = 1;                                                                                         //打开写保护，芯片只可读
 588   1              EA = 0;
 589   1      
 590   1              FMCON = 0x08;
 591   1              FMDATA = 0x96;                          //WE=1   打开flash写使能
 592   1              while((FMCON&0x0F)!=0);
 593   1              
 594   1              FMCON = 0x67;
 595   1              FMDATA = 0x96;                          //CWP=0
 596   1              while((FMCON&0x0F)!=0);          
 597   1      
 598   1              FMADRL = 0x02;
 599   1              FMCON = 0x6C;
 600   1              FMDATA = 0x1D;                          //启动向量0x1E  
 601   1              while((FMCON&0x0F)!=0);
 602   1              
 603   1              FMADRL = 0x03;                          //状态字节
 604   1              FMCON = 0x6C;                           //访问由FMADRL 寻址的用户配置信息
 605   1              FMDATA = 0x61;                          //CWP=1 AWP=1  BSB=1    
 606   1              while((FMCON&0x0F)!=0);
 607   1              
 608   1              while(1);
 609   1              //AUXR1 = 8;            
 610   1      
 611   1              return TRUE;            
 612   1      }
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 11  

 613          /*
 614          *********************************************************************************************************
 615          *                         RF模块软件下载                                                
 616          *
 617          * Description: 标号分配为0x0AFE，对射频模块的程序进行在系统升级
 618          *
 619          * Arguments  : 无
 620          *
 621          * Returns    : 无
 622          *********************************************************************************************************
 623          */
 624          unsigned char execDwnldSoft()
 625          {
 626   1              unsigned char xdata *tmpPtr = RxBuf;                                    //指向源数据的指针
 627   1              unsigned int  idata curSoftPktSn;                                               //当前软件包序号，16位数的临时变量
 628   1              unsigned char idata err;        
 629   1              unsigned int  idata total_len;
 630   1              unsigned char  idata i;
 631   1              unsigned int  idata datadrs;
 632   1              
 633   1              tmpPtr += 7;                                                                                    //取到数据的开头，包序号
 634   1              swapBytes(tmpPtr, (unsigned char *)&curSoftPktSn,2);    //取到包序号置于curSoftPktSn中  
 635   1              tmpPtr += 2;                                                                                    //指针指向数据长度
 636   1              swapBytes(tmpPtr, (unsigned char *)&total_len,2);               //取到数据长度  
 637   1              tmpPtr += 2;                                                                                    //指向数据部分
 638   1              if(curSoftPktSn == 0)                                                                   //第一个包
 639   1              {
 640   2                      if( total_len != 0x1C )                                                         //取得数据长度并指向起始地址
 641   2                      {                                                                                                                                                                        
 642   3                              return OTHER_ERR;                                                               //其他错误
 643   3                      }
 644   2                      tmpPtr += 0x18;                                                                         //指针指向文件CHECKSUM字节
 645   2                      swapBytes(tmpPtr, (unsigned char *)&softChecksum,2);//取得chechsum，保存于softChecksum
 646   2                      nextSoftPktSn = 1;
 647   2                      softDownLoad = DOING;
 648   2                      WP = 0;                                                                                         //关闭写保护，芯片可读可写
 649   2                      softLen = 0;
 650   2              }
 651   1              else                                                                                                    //非第一包
 652   1              {       
 653   2                      //dataLen = *tmpPtr++;
 654   2                      if(curSoftPktSn != nextSoftPktSn)                                       //校验包序号            
 655   2                      {
 656   3                              return OTHER_ERR;                                                               //包序号错
 657   3                      }
 658   2                      if(total_len>32)
 659   2                      {
 660   3                              return OTHER_ERR;                                                               //超出一页写数据范围,一页写32个字节     
 661   3                      } 
 662   2                      datadrs = curSoftPktSn - 1;
 663   2                      datadrs = datadrs * 32;
 664   2                      XmtDat[1] =  (unsigned char)datadrs;
 665   2                      XmtDat[0] =  (unsigned char)(datadrs>>8);
 666   2                      for(i=0;i<total_len;i++)
 667   2                      {
 668   3                              XmtDat[2+i] = *(tmpPtr+i);
 669   3                      }
 670   2                      watchdog();
 671   2                      err = ISendStrExt(0xA0,XmtDat,total_len+2);
 672   2                      watchdog();
 673   2                      if( err == FALSE )
 674   2                      {
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 12  

 675   3                              return OTHER_ERR;                                                               //E2PROM错
 676   3                      }               
 677   2                      softLen += total_len;                                                           //计算软件总长
 678   2                      
 679   2                      if(curSoftPktSn==3)
 680   2                      {
 681   3                              for( i = 0; i < 8; i++ )
 682   3                              {
 683   4                                      if(RxBuf[11+i]!= factry[i])
 684   4                                      {
 685   5                                              WP = 1;
 686   5                                              return OTHER_ERR;                                                               //E2PROM错      
 687   5                                      }
 688   4                              } 
 689   3                      }  
 690   2                      nextSoftPktSn++;
 691   2              }       
 692   1              return NO_ERR;                                                          //其他错误
 693   1      }
 694          /*计算异或校验和*/
 695          void calDefcksum(unsigned char *ptr, unsigned int len, unsigned char *checksum) small
 696          {
 697   1              unsigned char xdata tmpChecksum = 0;
 698   1      
 699   1              while(len--)
 700   1              {
 701   2                      tmpChecksum ^= *ptr++;
 702   2              }
 703   1              *checksum = tmpChecksum;  
 704   1      }
 705          /*
 706          *********************************************************************************************************
 707          *                         字节顺序交换
 708          *
 709          * Description: 字节流顺序交换
 710          *
 711          * Arguments  : 
 712          *                          result       指针，指向处理目标
 713          *                          src      指针，指向需要处理的字符串
 714          *
 715          * Returns    : 无
 716          *********************************************************************************************************
 717          */
 718          void swapBytes(unsigned char *src, unsigned char *result,unsigned char num)
 719          {
 720   1              unsigned char i;
 721   1              src += (num-1);
 722   1              for(i=0;i<num;i++)
 723   1              {
 724   2                      *result++ = *src--; 
 725   2              }
 726   1      }
 727          void delay(unsigned char time)
 728          {
 729   1              unsigned char x;
 730   1              unsigned int y;
 731   1              for(x=0;x<time;x++)
 732   1              {
 733   2                      watchdog();
 734   2                      for(y=0;y<0xFFFF;y++);
 735   2              }
 736   1      }
C51 COMPILER V7.06   BRO20W_PACKET                                                         04/24/2006 10:56:54 PAGE 13  

 737          
 738          void watchdog() 
 739          {
 740   1              EA = 0;                         //关闭中断 
 741   1              WFEED1 = 0xA5;          //执行清零第一部分 
 742   1              WFEED2 = 0x5A;          //执行清零第二部分 
 743   1              EA = 1;                         //开中断
 744   1                                      
 745   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2537    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      48
   IDATA SIZE       =   ----       8
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
